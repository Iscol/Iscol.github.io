<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于.net的学习-6]]></title>
    <url>%2F2017%2F07%2F20%2F%E5%85%B3%E4%BA%8E-net%E7%9A%84%E5%AD%A6%E4%B9%A0-6%2F</url>
    <content type="text"><![CDATA[类型转化及数组类型转换 1.隐式转换:系统自行的,不需要我们进行干预或者额外编码. 如97对应的编码是a, 2.显示转换:(转换类型如char)变量名前checked((转换类型如char)变量名前)检查是否溢出!Convert.ToString(xx);Parse()解析字符串成数字..]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于.net的学习-5]]></title>
    <url>%2F2017%2F07%2F14%2F%E5%85%B3%E4%BA%8E-net%E7%9A%84%E5%AD%A6%E4%B9%A0-5%2F</url>
    <content type="text"><![CDATA[字符及转义字符char类结构表示unicode字符char 变量名=’初值’;string类型变量可以看成是char变量的只读数组! char.IsNumber(xx);方 法————-说 明IsControl: 指示指定的Unicode字符是否属于控制字符类别IsDigit: 指示某个Unicode字符是否属于十进制数字类别IsHighSurrogate: 指示指定的Char对象是否为高代理项IsLetter: 指示某个Unicode字符是否属于字母类别IsLetterOrDigit: 指示某个Unicode字符是属于字母类别还是属于十进制数字类别IsLower: 指示某个Unicode字符是否属于小写字母类别IsLowSurrogate: 指示指定的Char对象是否为低代理项IsNumber: 指示某个Unicode字符是否属于数字类别IsPunctuation: 指示某个Unicode字符是否属于标点符号类别IsSeparator: 指示某个Unicode字符是否属于分隔符类别IsSurrogate: 指示某个Unichttp://time.qq.com/?pgv_ref=aiotimeode字符是否属于代理项字符类别IsSurrogatePair: 指示两个指定的Char对象是否形成代理项对IsSymbol: 指示某个Unicode字符是否属于符号字符类别IsUpper: 指示某个Unicode字符是否属于大写字母类别IsWhiteSpace: 指示某个Unicode字符是否属于空白类别Parse: 将指定字符串的值转换为它的等效Unicode字符ToLower: 将Unicode字符的值转换为它的小写等效项ToLowerInvariant: 使用固定区域性的大小写规则，将Unicode字符的值转换为其小写等效项ToString: 将此实例的值转换为其等效的字符串表示ToUpper: 将Unicode字符的值转换为它的大写等效项ToUpperInvariant: 使用固定区域性的大小写规则，将Unicode字符的值转换为其大写等效项TryParse: 将指定字符串的值转换为它的等效Unicode字符 字符串是由零个或多个字符组成的有限序列.string x=”初始值”; 字符集(charset):是一个系统支持的所有抽象字符的集合 大小写引用方法的不同!:转换字符串 X.ToUpper();转换字符 char.ToUpper(X); 字符串比较: 1.== 2.string.Equals(字符串1,字符串2)返回布尔值(string类型名先写上) 3.Compare多个重载 string.Compare(字符串1,字符串2)比较长度,返回数值.Compare(字符串1,字符串2,true)忽略大小写进行比较!字符串1.CompareTo(字符串2) 字符串格式化:WriteLine(“{0:C}”,123);输出¥123C 适用数字 含义:货币值D 适用证书 含义:一般整数 {0:D3}输入001,002等等P 百分比s=string.Format(‘使用C格式{0:C}\n’,123); 字符串截取:字符串1.Substring(整数n);将字符串1的前n个长度的字符截取掉,保留后面的字符串. 字符串1.Substring(整数n,整数m);保留从字符串1第n个长度开始m个长度的字符串 二者均返回一个新的字符串! 字符串分割 string[] xx=y.Split(new char[]{‘-‘,’,’})可以多个-,分割! 字符串合并: 1.+ 2.string.Concat(字符串1,字符串1,字符串1); 3.string.Join(“-“(合并后的分隔符),字符串数组); 字符串插入:字符串.Insert(插入位置,插入子串);填充字符串.PadRight(总长度);//以空格填充字符串.PadRight(总长度,要填充的字符)PadRight方法是在字符串的结尾通过添加指定的重复字符填充字符串.eg: abc// abcd/ .padright(5,”/“);PadLeft同理在子串开头添加指定字符 字符串的删除: 1.字符串.Remove(开始位置)之后的所有都会删除 2.字符串.Remove(开始位置,移出数)开始位置指字符串的索引,到移除数位置的字符都删除. 字符串的修建:删除字符串里出现的某些字符Trim(),TrimStart(),TrimEnd();清除空格Trim(“字符1”,”字符2”),删除掉某些字符.等同于Trim(“#%”,ToCharArray())删除多个字符Trim(“abcd”.ToCharArray())就是删除字符串头部及尾部出现的a,b,c,d字符. 字符串复制 string.copy(被复制的字符串);非静态方法CopyTo(要复制字符的其实位置,目标字符数组,目标数组中的开始存放位置,要复制的字符个数);例子:s.CopyTo(4, my, 0, 5); 字符串查找:IndexOf(): 字符串.IndexOf(要查找的字符或者字符串),返回要查找的第一次所出现的位置整数LastIndexOf()最后一次出现的位置整数,如果未找到返回负数.-1]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于.net的学习-4]]></title>
    <url>%2F2017%2F07%2F14%2F%E5%85%B3%E4%BA%8E-net%E7%9A%84%E5%AD%A6%E4%B9%A0-4%2F</url>
    <content type="text"><![CDATA[流程控制:分支语句,迭代语句,跳转语句 if switch while switch(表达式){case 常量表达式:条件语句;break;case 常量表达式:条件语句;break;case 常量表达式:条件语句;break;default:条件语句;break;} 三位运算符:只适用于判断具有两个结果的情况.条件判断表达式?成立时执行的语句:不成立时执行的语句; 迭代语句:while(条件表达式){代码语句} do..while:do{循环体语句}while(判断语句) for(初始条件;判断条件;循环条件){循环语句} foreach(类型,变量in集合){代码体}循环变量item是一个只读型的局部变量,这个值如果被修改编译器会发生错误.string(字符串)类型可以看做是char(字符)类型的一个集合. char.IsNumber(xx);方 法————-说 明IsControl: 指示指定的Unicode字符是否属于控制字符类别IsDigit: 指示某个Unicode字符是否属于十进制数字类别IsHighSurrogate: 指示指定的Char对象是否为高代理项IsLetter: 指示某个Unicode字符是否属于字母类别IsLetterOrDigit: 指示某个Unicode字符是属于字母类别还是属于十进制数字类别IsLower: 指示某个Unicode字符是否属于小写字母类别IsLowSurrogate: 指示指定的Char对象是否为低代理项IsNumber: 指示某个Unicode字符是否属于数字类别IsPunctuation: 指示某个Unicode字符是否属于标点符号类别IsSeparator: 指示某个Unicode字符是否属于分隔符类别IsSurrogate: 指示某个Unicode字符是否属于代理项字符类别IsSurrogatePair: 指示两个指定的Char对象是否形成代理项对IsSymbol: 指示某个Unicode字符是否属于符号字符类别IsUpper: 指示某个Unicode字符是否属于大写字母类别IsWhiteSpace: 指示某个Unicode字符是否属于空白类别Parse: 将指定字符串的值转换为它的等效Unicode字符ToLower: 将Unicode字符的值转换为它的小写等效项ToLowerInvariant: 使用固定区域性的大小写规则，将Unicode字符的值转换为其小写等效项ToString: 将此实例的值转换为其等效的字符串表示ToUpper: 将Unicode字符的值转换为它的大写等效项ToUpperInvariant: 使用固定区域性的大小写规则，将Unicode字符的值转换为其大写等效项TryParse: 将指定字符串的值转换为它的等效Unicode字符 跳转语句 break语句的作用: 1.switch语句中用于从case语句中跳出,结束分支语句. 2.跳出迭代语句,结束当前循环. continue语句用于停止本次迭代,并非跳出迭代语句.然后继续返回开始继续进行.(只能用于迭代语句中!) return; 定义的时候要写成void没有返回值;return 表达式;return语句只能出现在方法中,当调用方法时,执行到return语句时,直接跳转到Main函数. goto标识符:标识程序位置的方法作用:当程序执行到goto语句时,程序会直接跳到标识符所标识的程序位置,继续执行代码. goto error(语句块),error:{}]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[便利小工具之获取ip及地址]]></title>
    <url>%2F2017%2F07%2F13%2F%E4%BE%BF%E5%88%A9%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%B9%8B%E8%8E%B7%E5%8F%96ip%E5%8F%8A%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[获取用户ip及地址的简单第三方插件]]></content>
      <categories>
        <category>ip定位</category>
      </categories>
      <tags>
        <tag>第三方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于.net的学习-3]]></title>
    <url>%2F2017%2F07%2F13%2F%E5%85%B3%E4%BA%8E-net%E7%9A%84%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[运算符数学运算符var=var2++ 先用后加,var=var2,var2+1;var=++var2 先加后用 赋值运算符a+=b: a=a+b;a-=b: a=a-b; 关系运算符操作数为数值类型,则比较两个数的大小;操作数是字符类,则比较其unicode编码大小;操作数为两个字符串.则只能用==或者!=. 运算符前一个操作数为true值时,不再计算执行后一个操作数的内容 1字节(byte)=8位(bit) 1K=1024Byte]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于.net的学习-2]]></title>
    <url>%2F2017%2F07%2F11%2F%E5%85%B3%E4%BA%8E-net%E7%9A%84%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[开始学习C#了net框架C#语言 创建应用程序步骤 1.使用C#编写代码 2.把代码编译成CIL(通用编程语言),存储在程序集中 3.在执行代码中,使用JIT(编译器)将代码编程为本机代码 4.在托管的CLR(通用语言运行时)环境下运行本机代码,以及其他应用程序 .Sln:解决方案文件.csroj:项目文件.cs:类文件命名空间namespace xx:.net中提供应用程序代码容器的方式,这样就可以唯一的标识代码及其内容.关键字namespace 在vs创建控制台应用程序时会自动加入命名空间,以”层”的形势存在,如果有多层以”.”分开 标识符:只能由大小写字母,数字和下划线组成.必须以字母或者下划线开头.区分大小写.如果C#关键字作为标识符就在前面加上@标识符的命名最好好辨认(可用英文) 赋值:这是写入内存的一个郭晨,一旦给一个变量新值,那么变量中的老值也就不存在了. const double pi = 3.14; //定义常量 const(关键字) 数据类型 常量名=常量值 变量的作用域为包含它的大括号!!! @作用: 1.Console.Write(@”1111\n”);转义失效会被输出成1111\n 2.字符串跨行,开始加@后换行不需要用+号 3.加入@可以让一些关键字允许成为标识符(类名,变量名等)如@class 数据类型:值类型:在栈中操作 int a=100;包括数值类型 布尔类型字符类型(保存单个字符的值)引用类型:在堆中分配存储单元 string s=”我要学习”(字符串会对应一个内存地址,然后s存在值类型里指向堆中),对象类型(obj)和字符串类型 内存原理内存可以划分为三大块堆:栈:静态存储区:存储静态成员 字符串不可变性:当给一个字符串重新赋值后,老值并没有重新销毁,二手重新开辟了一块空间存储新值.当程序结束后,GC(垃圾收集)扫描整个内存,如果发现有的空间没有被指向,则立即把它销毁.字符串可以看做是char类型的一个只读数组. Console.ReadLine();接受用户输入 Console.WriteLine(“{0}{1}{2}”, var1, comparison, var2); //注意参数的设置,对应012 //双引号中的内容可以原样输出,但是转移字符集索引号{i}除外.索引号必须从零不间断顺延,否则报错! 表达式Convert.toDouble()字符类型转换除法运算符:如果5和3都是整数型，相除也是整型，/会把余数去掉;如果5和3都是整数型，相除是double型，/会把余数去掉]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js的学习-4]]></title>
    <url>%2F2017%2F07%2F10%2F%E5%85%B3%E4%BA%8Ejs%E7%9A%84%E5%AD%A6%E4%B9%A0-4%2F</url>
    <content type="text"><![CDATA[js的小细节onload 和 onunload 事件会在用户进入或离开页面时被触发。 onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。 onload 和 onunload 事件可用于处理 cookie。 onchange 事件常结合对输入字段的验证来使用。当内容发生变化时会调用这个生成函数进行一些操作. addEventListener() 方法用于向指定元素添加事件句柄。 addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。 你可以向一个元素添加多个事件句柄。 你可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。 你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。 addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。 当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。 你可以使用 removeEventListener() 方法来移除事件的监听。element.addEventListener(event, function, useCapture); 第一个参数是事件的类型 (如 “click” 或 “mousedown”). 第二个参数是事件触发后调用的函数。 第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。 当用户重置窗口大小时添加事件监听：//window.addEventListener(“resize”, function(){ // document.getElementById(“demo”).innerHTML = sometext;//}); 事件传递的两种方式:事件冒泡和事件捕获! 事件冒泡:内部元素优先触发,然后再触发外部元素 事件捕获:外部元素优先触发. 语法://document.getElementById(“myDiv”).addEventListener(“click”, myFunction, true);默认为false即冒泡传递. 找到您希望删除的子元素，然后使用其 parentNode 属性来找到父元素：var child=document.getElementById(“p1”);child.parentNode.removeChild(child); ////////////////////////////////////////// toUpperCase() 将文本转化成大写.toLowerCase();转化小写 round()四舍五入。Math.round(2.5) random()如何使用 random() 来返回 0 到 1 之间的随机数。 max()如何使用 max() 来返回两个给定的数中的较大的数。（在 ECMASCript v3 之前，该方法只有两个参数。） min()如何使用 min() 来返回两个给定的数中的较小的数。（在 ECMASCript v3 之前，该方法只有两个参数。） Math 对象的 floor() 方法和 random() 来返回一个介于 0 和 11 之间的随机数：document.write(Math.floor(Math.random()*11)); 实用的 JavaScript 方案（涵盖所有浏览器）： 确定浏览器窗口的尺寸。var w=window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth; var h=window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; window.screen对象在编写时可以不使用 window 这个前缀。 一些属性：screen.availWidth - 可用的屏幕宽度screen.availHeight - 可用的屏幕高度 history.back() - 与在浏览器点击后退按钮相同history.forward() - 与在浏览器中点击按钮向前相同例如: window.history.back(); 确认框 confirm(“sometext”);提示框prompt(“sometext”,”defaultvalue”);]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于.net的学习]]></title>
    <url>%2F2017%2F07%2F10%2F%E5%85%B3%E4%BA%8E-net%E7%9A%84%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[@item的用法友链http://www.cnblogs.com/lgxlsm/p/5487894.htmlview.bag及view.data的用法友链http://www.cnblogs.com/wintersun/archive/2012/01/21/2328563.html@ 多行代码时需要包含在大括号内{}和每句代码后都需要加分号; @@{ ViewBag.Title = “Index”; ViewBag.Name = “Linq”; ViewBag.IsOk = false; List list = new List() { “11”, “22”, “33”, “44”, “55”, “66” }; ViewBag.Description = “迷失之牙“;}@ 单行代码时不需要分号结束 @@DateTime.Now 名称：@(“欢迎,” + ViewBag.Name) 状态：@(ViewBag.IsOk ? “是” : “否”) @@Linq @if (ViewBag.IsOk != null &amp;&amp; ViewBag.IsOk){ @:启用}else{ @:停用} @if (ViewBag.IsOk != null &amp;&amp; ViewBag.IsOk){ 1.启用}else{ 2.停用} @if (ViewBag.IsOk != null &amp;&amp; ViewBag.IsOk){ 1. 启用 }else{ 2. 停用 } @foreach (var item in list) { @item }@ 所有Razor语法输出的变量都会被HTML编码（HTMLEncode）后输出，如果想里面的HTML标签生效要调用Html.Raw方法 @@ViewBag.Description@Html.Raw(ViewBag.Description) @{ 混合例子 @(ViewBag.Name) foreach (var item in list) { @item } }]]></content>
      <categories>
        <category>net</category>
      </categories>
      <tags>
        <tag>item的语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于.net的学习]]></title>
    <url>%2F2017%2F07%2F06%2F%E5%85%B3%E4%BA%8E-net%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[原文链接http://blog.csdn.net/truong/article/details/29825913表设计：1、 数据库表命名，将业务和基础表区分，采用驼峰表示法等。2、 数据不要物理删除，应该加一个标志位，以防用户后悔时，能够恢复。还有就是比如人员登记加入某系统，采用登记卡的方式，一段时间后该人员退出了该系统，那么此时我们将该人员对应的记录标记为不可用，那么这个人就从系统中移除了，一段时间后这个人又回来了，那么我们直接修改标记字段为可用，这个人就从新加入系统，避免了其它信息的录入。3、 数据是否有效的标示字段，其作用为：例如某条记录只有经过某个流程或者被某个人员审核通过后才有用，在这之前一直没有用。 4、 排序字段，按照某种类型来排序（sortcode）最好不依赖id排序，这样方便我们查询记录时按照某种方式排序，而不依赖id。5、 数据是否允许删除和允许编辑，例如管理员不能删除，这样我们在查询数据时就可以根据该字段标示来决定某条记录是否可以编辑。而不用固化到代码中。 6、 增加备注字段，虽然我们考虑了很多用户需要输入信息的需求，但是无论何时我们都不可能考虑全，因此可以定义一个备注字段，允许用户将其它的信息填写在这里。无论表设计的再神奇，那么还是加一个备注字段。7、 将记录创建人Id和记录创建人名字做为字段，这样看起来或许感到冗余有了Id还要名字干什么，使用住外键关联不就可以了吗，但是我们可以这样思考，如果只使用名字，那么人多了免不了名字重复，只使用id当然没有问题，但是我们查询时为了知道创建者的人名需要关联查询另外一张表，性能上不好，而且数据库看起来不是那么一目了然。并且创建人的名字也不是经常修改的。 8、 添加时间，有添加时间可以明确知道记录什么时候添加的。 9、 修改时间，可以知道记录什么时候被修改了，一旦数据出现问题，可以根据修改时间来定位问题。比如某人在这个时间做了哪些事。10、 修改人id和名字，其作用就是标记谁对记录做了修改 11、 最后修改人 12、 最后修改时间 13、 记录所属公司id，方便我们查询只属于某个公司的记录 14、 记录所属部门id，方便我们查询只属于某个部门的记录 15、 记录所属工作组id，方便我们查询只属于某个工作组的记录16、基本表及其字段之间的关系, 应尽量满足第三范式。但是，满足第三范式的数据库设计，往往不是最好的设计。为了提高数据库的运行效率，常常需要降低范式标准：适当增加冗余，达到以空间换时间的目的。17、若两个实体之间存在多对多的关系，则应消除这种关系。消除的办法是，在两者之间增加第三个实体。这样，原来一个多对多的关系，现在变为两个一对多的关系。要将原来两个实体的属性合理地分配到三个实体中去。这里的第三个实体，实质上是一个较复杂的关系，它对应一张基本表。一般来讲，数据库设计工具不能识别多对多的关系，但能处理多对多的关系。18、 主键PK的取值方法，PK是供程序员使用的表间连接工具，可以是一无物理意义的数字串, 由程序自动加1来实现。也可以是有物理意义的字段名或字段名的组合。不过前者比后者好。当PK是字段名的组合时，建议字段的个数不要太多，多了不但索引占用空间大，而且速度也慢。19、主键与外键在多表中的重复出现, 不属于数据冗余，这个概念必须清楚，事实上有许多人还不清楚。非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。 〖例4〗：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。20、中间表是存放统计数据的表，它是为数据仓库、输出报表或查询结果而设计的，有时它没有主键与外键(数据仓库除外)。临时表是程序员个人设计的，存放临时记录，为个人所用。基表和中间表由DBA维护，临时表由程序员自己用程序自动维护。21、防止数据库设计打补丁的方法是“三少原则” (1) 一个数据库中表的个数越少越好。只有表的个数少了，才能说明系统的E–R图少而精，去掉了重复的多余的实体，形成了对客观世界的高度抽象，进行了系统的数据集成，防止了打补丁式的设计； (2) 一个表中组合主键的字段个数越少越好。因为主键的作用，一是建主键索引，二是做为子表的外键，所以组合主键的字段个数少了，不仅节省了运行时间，而且节省了索引存储空间； (3) 一个表中的字段个数越少越好。只有字段的个数少了，才能说明在系统中不存在数据重复，且很少有数据冗余，更重要的是督促读者学会“列变行”，这样就防止了将子表中的字段拉入到主表中去，在主表中留下许多空余的字段。所谓“列变行”，就是将主表中的一部分内容拉出去，另外单独建一个子表。这个方法很简单，有的人就是不习惯、不采纳、不执行。 数据库设计的实用原则是：在数据冗余和处理速度之间找到合适的平衡点。“三少”是一个整体概念，综合观点，不能孤立某一个原则。该原则是相对的，不是绝对的。“三多”原则肯定是错误的。试想：若覆盖系统同样的功能，一百个实体(共一千个属性) 的E–R图，肯定比二百个实体(共二千个属性)的E–R图，要好得多。 提倡“三少”原则，是叫读者学会利用数据库设计技术进行系统的数据集成。数据集成的步骤是将文件系统集成为应用数据库，将应用数据库集成为主题数据库，将主题数据库集成为全局综合数据库。集成的程度越高，数据共享性就越强，信息孤岛现象就越少，整个企业信息系统的全局E—R图中实体的个数、主键的个数、属性的个数就会越少。 提倡“三少”原则的目的，是防止读者利用打补丁技术，不断地对数据库进行增删改，使企业数据库变成了随意设计数据库表的“垃圾堆”，或数据库表的“大杂院”，最后造成数据库中的基本表、代码表、中间表、临时表杂乱无章，不计其数，导致企事业单位的信息系统无法维护而瘫痪。 “三多”原则任何人都可以做到，该原则是“打补丁方法”设计数据库的歪理学说。“三少”原则是少而精的原则，它要求有较高的数据库设计技巧与艺术，不是任何人都能做到的，因为该原则是杜绝用“打补丁方法”设计数据库的理论依据。22、在给定的系统硬件和系统软件条件下，提高数据库系统的运行效率的办法是： (1) 在数据库物理设计时，降低范式，增加冗余, 少用触发器, 多用存储过程。 (2) 当计算非常复杂、而且记录条数非常巨大时(例如一千万条)，复杂计算要先在数据库外面，以文件系统方式用C++语言计算处理完成之后，最后才入库追加到表中去。这是电信计费系统设计的经验。 (3) 发现某个表的记录太多，例如超过一千万条，则要对该表进行水平分割。水平分割的做法是，以该表主键PK的某个值为界线，将该表的记录水平分割为两个表。若发现某个表的字段太多，例如超过八十个，则垂直分割该表，将原来的一个表分解为两个表。 (4) 对数据库管理系统DBMS进行系统优化，即优化各种系统参数，如缓冲区个数。 (5) 在使用面向数据的SQL语言进行程序设计时，尽量采取优化算法。 总之，要提高数据库的运行效率，必须从数据库系统级优化、数据库设计级优化、程序实现级优化，这三个层次上同时下功夫。主键设计：1、不建议用多个字段做主键，单个表还可以，但是关联关系就会有问题，主键自增是高性能的。导入导出就有问题2、一般情况下，如果有两个外键，不建议采用两个外键作为联合住建，另建一个字段作为主键。除非这条记录没有逻辑删除标志，且该表永远只有一条此联合主键的记录。3、一般而言，一个实体不能既无主键又无外键。在E—R 图中, 处于叶子部位的实体, 可以定义主键，也可以不定义主键(因为它无子孙), 但必须要有外键(因为它有父亲)。主键与外键的设计，在全局数据库的设计中，占有重要地位。当全局数据库的设计完成以后，有个美国数据库设计专家说：“键，到处都是键，除了键之外，什么也没有”，这就是他的数据库设计经验之谈，也反映了他对信息系统核心(数据模型)的高度抽象思想。因为：主键是实体的高度抽象，主键与、外键的配对，表示实体之间的连接。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL设计技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于浏览器兼容性汇总]]></title>
    <url>%2F2017%2F06%2F26%2F%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[关于浏览器兼容性的问题真的需要慢慢积累,但仍有很多可以总结的地方,将自己遇到的进行汇总.1:强制使360浏览器在打开的时候默认为极速模式!//&lt;//head&gt;// &lt;//meta http-equiv=//“X-UA-Compatible” content=//“IE=edge” /&gt;// &lt;//meta name=//“renderer” content=//“webkit”/&gt;//&lt;//head&gt;注意尾缀是/&gt; !(//斜杠去掉)]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>浏览器兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js的学习-3]]></title>
    <url>%2F2017%2F06%2F26%2F%E5%85%B3%E4%BA%8Ejs%E7%9A%84%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[正则表达式var patt = /runoob/i/runoob/i 是一个正则表达式。runoob 是一个正则表达式主体 (用于检索)。i 是一个修饰符 (搜索不区分大小写)。JavaScript 保留关键字 Javascript 的保留关键字不可以用作变量、标签或者函数名。有些保留关键字是作为 Javascript 以后扩展使用。abstract arguments boolean break bytecase catch char class constcontinue debugger default delete dodouble else enum eval exportextends false final finally floatfor function goto if implementsimport in instanceof int interfacelet long native new nullpackage private protected public returnshort static super switch synchronizedthis throw throws transient truetry typeof var void volatilewhile with yield JSON 语法规则 数据为 键/值 对。 数据由逗号分隔。 大括号保存对象 方括号保存数组 点我! 函数显式参数(Parameters)与隐式参数(Arguments)this 关键字:一般而言，在Javascript中，this指向函数执行时的当前对象。this 是保留关键字，你不能修改 this 的值。闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。http://www.cnblogs.com/wangfupeng1988/p/3977924.html原型链和闭包需要好好学习及研究,重点 闭包:应用的两种情况,函数作为返回值,函数作为参数传递.]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js的学习-2]]></title>
    <url>%2F2017%2F06%2F23%2F%E5%85%B3%E4%BA%8Ejs%E7%9A%84%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[Constructor属性:返回所有javascript变量的构造函数JavaScript 类型转换JavaScript 变量可以转换为新变量或其他数据类型：通过使用 JavaScript 函数通过 JavaScript 自身自动转换toExponential() 把对象的值转换为指数计数法。toFixed(2) 把数字转换为字符串，结果的小数点后有指定位数的数字。例如120.00toPrecision() 把数字格式化为指定的长度。 方法 描述getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。getFullYear() 从 Date 对象以四位数字返回年份。getHours() 返回 Date 对象的小时 (0 ~ 23)。getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。getMonth() 从 Date 对象返回月份 (0 ~ 11)。getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 方法 描述parseFloat() 解析一个字符串，并返回一个浮点数。parseInt(string, radix) 解析一个字符串，并返回一个整数string 必需。要被解析的字符串。radix可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于JS的学习-1]]></title>
    <url>%2F2017%2F06%2F22%2F%E5%85%B3%E4%BA%8EJS%E7%9A%84%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[JavaScript 语句标识符JavaScript 语句通常以一个 语句标识符 为开始，并执行该语句。语句标识符是保留关键字不能作为变量名使用。下表列出了 JavaScript 语句标识符 (关键字) ：语句 描述break 用于跳出循环。catch 语句块，在 try 语句块执行出错时执行 catch 语句块。continue 跳过循环中的一个迭代。do … while 执行一个语句块，在条件语句为 true 时继续执行该语句块。for 在条件语句为 true 时，可以将代码块执行指定的次数。for … in 用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。function 定义一个函数if … else 用于基于不同的条件来执行不同的动作。return 退出函数switch 用于基于不同的条件来执行不同的动作。throw 抛出（生成）错误 。try 实现错误处理，与 catch 一同使用。var 声明一个变量。while 当条件语句为 true 时，执行语句块。 声明变量类型当您声明新变量时，可以使用关键词 “new” 来声明其类型：var carname=new String;var x= new Number;var y= new Boolean;var cars= new Array;var person= new Object; 函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 JavaScript 变量生命周期JavaScript 变量生命周期在它声明时初始化。局部变量在函数执行完毕后销毁。全局变量在页面关闭后销毁。没有声明就使用的变量，默认为全局变量，不论这个变量在哪被使用。HTML 事件HTML 事件可以是浏览器行为，也可以是用户行为。以下是 HTML 事件的实例：HTML 页面完成加载HTML input 字段改变时HTML 按钮被点击通常，当事件发生时，你可以做些事情。在事件触发时 JavaScript 可以执行一些代码。HTML 元素中可以添加事件属性，使用 JavaScript 代码来添加 HTML 元素。字符串添加转义字符来使用引号转义字符 转义字符的意义\n 回车换行\t 横向跳到下一制表位置\v 竖向跳格\b 退格\r 回车\f 走纸换页\ 反斜线符”\”\’ 单引号符\a 鸣铃对字符串和数字进行加法运算两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串，break 语句可用于跳出循环。continue 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）：continue 语句（带有或不带标签引用）只能用在循环中。break 语句（不带标签引用），只能用在循环或 switch 中。通过标签引用，break 语句可用于跳出任何 JavaScript 代码块：NaN 的数据类型是 number数组(Array)的数据类型是 object日期(Date)的数据类型为 objectnull 的数据类型是 object未定义变量的数据类型为 undefined]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex-box-1]]></title>
    <url>%2F2017%2F06%2F19%2Fflex-box-1%2F</url>
    <content type="text"><![CDATA[强烈推荐张鑫旭的文章看看,很有意思链接:http://www.zhangxinxu.com/wordpress/2010/12/css-box-flex属性，然后弹性盒子模型简介/ display: box;与display: flex;display:box box-flex 是比较早期的 flex 布局用法吧，标准化里面没有了，display:flex 是标准的下面开始介绍主要内容一: display: flex;声明:.box{ display: flex;}如果是行内元素使用则:.box{ display: inline-flex;}换行.box{ flex-wrap: nowrap | wrap | wrap-reverse;}项目属性:1 order.item { order: ;}属性定义项目的排列顺序。数值越小，排列越靠前，默认为02 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。3 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。4 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。5 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。6 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 二:display: box;父标签属性然后子标签按照比例划分box-flex: 2;当然兄弟标签中也可以是固定宽度,则剩下的按照比例划分,当涉及到边框距离时则按照比例划分的标签会缩短自己的大小来满足.1.box-orient:确定子元素的方向,横着还是竖着.horizontal | vertical | inline-axis | block-axis | inherithorizontal与inline-axis(默认)一致,横排vertical与block-axis一致,纵列http://www.zhangxinxu.com/study/201012/css-box-orient-demo.html 2.box-direction:box-direction是用来确定子元素的排列顺序normal | reverse | inheritnormal:表示按照正常顺序排列。所谓正常顺序，就是我们看书写文字的顺序，从左往右，由上至下，先出现的元素，就上面或是左边。reverse:表示反转inherit:继承父元素 3.box-align:box-align与box-pack都是决定盒子内部剩余空间怎么使用的。在行为效果上就是表现为“对齐”.start | end | center | baseline | stretchstretch为默认值，为拉伸，也就是父标签高度过高，其孩子元素的高度就多高 4.box-pack:父标签水平遗留空间的使用start | end | center | justify配合box-direction属性使用其中star为默认属性justify表示两端对齐5.box-lines:决定子元素是可以换行显示single | multiple]]></content>
      <categories>
        <category>flex-box</category>
      </categories>
      <tags>
        <tag>flex-box基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ES6的学习-1]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%85%B3%E4%BA%8EES6%E7%9A%84%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[网站链接,预测要学完JS后开始http://es6.ruanyifeng.com/#docs/intro]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿头条表格类型设计]]></title>
    <url>%2F2017%2F06%2F12%2F%E4%BB%BF%E5%A4%B4%E6%9D%A1%E8%A1%A8%E6%A0%BC%E7%B1%BB%E5%9E%8B-C%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[捯饬了一天的菜单悬浮效果代码如下原链接:http://www.cnblogs.com/sorex/archive/2011/06/30/2093499.html修改后因js无法加载所以无法显示,可以下载源码后本地显示http://oqfuveidu.bkt.clouddn.com/index.htmlhttp://oqfuveidu.bkt.clouddn.com/migrate.js宽度修改在 $(“#MyTable_tableFixClone”).html(str); 后面加上宽度如: $(“#MyTable_tableFixClone”).html(str).width(14*100);]]></content>
      <categories>
        <category>jQuery导航菜单特效</category>
      </categories>
      <tags>
        <tag>excel悬浮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node-js的学习-博客5]]></title>
    <url>%2F2017%2F06%2F12%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A25%2F</url>
    <content type="text"><![CDATA[Promise解读Mongodb中的populate方法findOne没啥事千万不要把代码往上放,敏感到直接需要转义,这样真的很费劲一翻开上次的内容简直乱糟糟小步骤首先往路由里添加router.get路径,然后进行渲染res,render;然后添加对应的html界面,引用bootstrap模板;当然有新的分类时要进行schemas添加,然后再对model进行添加最后再对数据库进行操作处理,findOne().then(function(){})最后再对操作成功后的提示界面进行渲染,增加响应的界面及返回链接.////////////////////////Promise解读ES6引入Promise原文链接:http://www.jianshu.com/p/87183851756f简要分析如下:PromiseStatus：用于记录Promise对象的三种状态，这三中状态分别是：pending：待定状态，Promise对象刚被初始化的状态fulfilled：完成状态，承诺被完成了的状态rejected：拒绝状态，承诺完成失败的状态Promise的初始状态是pending。随后会更具承诺完成的情况更改PromiseStatus的值。PromiseStatus：用于记录返回的数据或者错误。当承诺完成时，会把返回的数据赋给PromiseStatus。如果承诺执行失败了，那么失败的原因也会赋给此变量。resolve()和reject()：Promise构造函数中有两个闭包的函数resolve()和reject()。在new一个新的Promise的时候会传递一件你需要做的事情（executor）。这个executor是一个函数，在Promise的构造函数中它会被传入两个参数，这两个参数即我们的两个闭包的函数resolve()和reject()，以便你在executor中判定是否完成了你的承诺。 Mongodb中的populate方法 原文链接:http://blog.csdn.net/hellochenlu/article/details/50467563 先科普下mongoDB数据库 mongoDB是文档型数据库,那么不如SQL这种关系型数据库在操作关联的时候那样方便,于是Popolation方法应用而生. Mongoose是MongoDB的ODM,即将数据库的数据转化为代码对象的库,使用转化后的对象可以直接对数据库的数据进行操作. 在定义Schema的时候，如果设置某个 field 关联另一个Schema， 那么在获取 document 的时候就可以使用 Population 功能通过关联Schema的 field 找到关联的另一个 document， 并且用被关联 document 的内容替换掉原来关联字段(field)的内容。 Query.populate(path, [select], [model], [match], [options]) path 类型：String或Object。 String类型的时， 指定要填充的关联字段，要填充多个关联字段可以以空格分隔。 Object类型的时，就是把 populate 的参数封装到一个对象里。当然也可以是个数组。下面的例子中将会实现。select 类型：Object或String，可选，指定填充 document 中的哪些字段。 Object类型的时，格式如:{name: 1, _id: 0},为0表示不填充，为1时表示填充。 String类型的时，格式如:”name -_id”，用空格分隔字段，在字段名前加上-表示不填充。详细语法介绍query-selectmodel 类型：Model，可选，指定关联字段的 model，如果没有指定就会使用Schema的ref。match 类型：Object，可选，指定附加的查询条件。options 类型：Object，可选，指定附加的其他查询选项，如排序以及条数限制等等。 findOne是返回符合条件的第一条记录，然后关闭游标。find返回符合条件的所有记录。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node-js的学习-博客4]]></title>
    <url>%2F2017%2F06%2F08%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A24%2F</url>
    <content type="text"><![CDATA[不知道是不是我太菜了,还是github太敏感了,网站崩了一上午了,找了许多原因查看了很多的网站,终于找到了一些问题先贴hexo的网站https://hexo.io/themes/然后是问题:$ hexo g//命令INFO Start processingERROR Theme config load failed.ERROR Process failed: _config.ymlYAMLException: bad indentation of a mapping entry at line 73, column 5: hexo-generator-feed报错!对!就是最下面的这个 - hexo-generator-feed 我也看不懂啥意思,找了半天理由,于是我机制的去官网档了一份原来的,一对比,这是多出来的,之前我还在怀疑空格的问题,原来这不是亲生的!删!痛快华丽丽的删了,然后瞬间正常.简直不要太脆弱.赶紧继续今天的学习!记录下mongodb的开启方式,省的又忘记了首先要找到mongodb的路径D:\mongodb\bincmd要跳到指定路径下,后启动mongod –dbpath=E:\Blog2\db –port=27018 如果git提交不上多数是因为敏感词在模板语法两边用 进行注释即可 ESC下面的键 //&amp;#123% extends &#39;layout.html&#39;%} 继承模板页进行渲染,实现模块复用//layout页面复用//// &amp;#123% block maini %}&amp;#123% endblock %}////index页面//&amp;#123% extends &#39;layout.html&#39;%}//&amp;#123% block maini%}//// Hello, &amp;#123&amp;#123userInfo.username}}!// 欢迎进入管理////&amp;#123% endblock%}////maini.js//进行渲染 res.render(‘mainm/index’,&amp;#123// userInfo:req.userInfo //全局路由均可访问//});//index.html可以进行判断语法//&amp;#123%if userInfo.isAdmin%}////&amp;#123%else%}////&amp;#123%endif%}//////tr&gt;th*4 按table键会重新加载样式// User.find().limit(2).then(function()&amp;#123})//limit()限制条数// &amp;#123% extends &#39;layout.html&#39;%}和 &amp;#123%include &#39;page.html&#39;%}有什么区别吗?// layout是最大的包裹层// 子页面通过extend来继承父页面的html,页面变量不会继承// include同级引入一段页面,可以继承数据,需要通过js路由进行调用.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-博客3]]></title>
    <url>%2F2017%2F06%2F07%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A23%2F</url>
    <content type="text"><![CDATA[本章设计到用户前端页面逻辑设计等主要的内容是router路由的学习话不多说action~ 概念链接:http://www.cnblogs.com/zapple/p/5683016.html一:模块依赖,例如var express = require(‘express’), http = require(‘http’), path = require(‘path’), mongoose = require(‘mongoose’), hash = require(‘./pass’).hash;var app = express() 二:配置和中间件中间件:Express里有个中间件（middleware）的概念。所谓中间件，就是在收到请求后和发送响应之前这个阶段执行的一些函数。中间件其实就是一个访问express应用串入的req，res，nex参数的函数，这个函数可以访问任何通过req，res传入的资源。要在一条路由的处理链上插入中间件，可以使用express对象的use方法。该方法原型如下： app.use([path,] function [, function…])当app.use没有提供path参数时，路径默认为“/”。当你为某个路径安装了中间件，则当以该路径为基础的路径被访问时，都会应用该中间件。比如你为“/abcd”设置了中间件，那么“/abcd/xxx”被访问时也会应用该中间件。中间件函数的原型如下： function (req, res, next)第一个参数是Request对象req。第二个参数是Response对象res。第三个则是用来驱动中间件调用链的函数next，如果你想让后面的中间件继续处理请求，就需要调用next方法。给某个路径应用中间件函数的典型调用是这样的：app.use(‘/abcd’, function (req, res, next) { console.log(req.baseUrl); next();}) Express提供了一个static中间件，可以用来处理网站里的静态文件的GET请求，可以通过express.static访问。express.static的用法如下：express.static(root, [options])第一个参数root，是要处理的静态资源的根目录，可以是绝对路径，也可以是相对路径。第二个可选参数用来指定一些选项，比如maxAge、lastModified等var options = { dotfiles: ‘ignore’, etag: false, extensions: [‘htm’, ‘html’], index: false, maxAge: ‘1d’, redirect: false, setHeaders: function (res, path, stat) { res.set(‘x-timestamp’, Date.now()); }}app.use(express.static(‘public’, options));上面这段代码将当前路径下的public目录作为静态文件，并且为Cache-Control头部的max-age选项为1天。还有其它一些属性，请对照express.static的文档来理解。使用express创建的HelloExpress项目的app.js文件里有这样一行代码：app.use(express.static(path.join(_dirname, ‘public’)));这行代码将HelloExpress目录下的public目录作为静态文件交给static中间件来处理，对应的HTTP URI为“/”。path是一个Node.js模块，_dirname是Node.js的全局变量，指向当前运行的js脚本所在的目录。path.join()则用来拼接目录。 routerExpress还提供了一个叫做Router的对象，行为很像中间件，你可以把Router直接传递给app.use，像使用中间件那样使用Router。另外你还可以使用router来处理针对GET、POST等的路由，也可以用它来添加中间件，总之你可以将Router看作一个微缩版的app。 var express = require(‘express’);var router = express.Router(); / GET home page. /router.get(‘/‘, function(req, res, next) { res.render(‘index’, { title: ‘Express’ });});module.exports = router;index.js创建了一个Router实例，然后调用router.get为“/”路径应用了路由函数。最后呢使用module.exports将Router对象导出。下面是app.js里引用到index.js的代码：var routes = require(‘./routes/index’);…app.use(‘/‘, routes);第一处，require(‘./routes/index’)将其作为模块使用，这行代码导入了index.js，并且将index.js导出的router对象保存在变量routes里以供后续使用。注意，上面代码里的routes就是index.js里的router。第二处代码，把routes作为一个中间件，挂载到了“/”路径上。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活-电影喜剧之王]]></title>
    <url>%2F2017%2F06%2F06%2F%E7%94%9F%E6%B4%BB-%E7%94%B5%E5%BD%B1%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%2F</url>
    <content type="text"><![CDATA[只有看懂了《喜剧之王》这些细节，才会知道周星驰有多伟大!《喜剧之王》这部戏，除了刻画了柳飘飘跟尹天仇的爱情之外，还有尹天仇对于他梦想的追求这一条主线。对于这部自传体电影，星爷在表现一个未成名的小人物在奋斗时的彷徨和坚持可是下了大功夫的，每一处细节都值得我们反复观看。尹天仇因为在片场表演欲望太过于强烈闯了大祸，而被导演和李娟儿（莫文蔚）大骂一场赶出了片场。在回家途中，想拿一个盒饭当午餐而被场务（吴孟达）制止并辱骂。场务把饭扔给了狗狗：“屎你是一滩屎，命比蚁便宜……”面对这样的羞辱，几秒钟之内，尹天仇从强颜欢笑到笑不出来的尴尬，他只能默默忍受。（这里不得不赞一下星爷的演技，把小人物的懦弱演得无比贴切）孤独的夜晚，狭小的房间，失意落魄的尹天仇。不知前路如何。墙上那一堆海报，给这黑暗的房间带来了一丝暖色。发呆时面对着这些海报，吃饭时也面对着这些海报，因为这些都是他的梦想。或许大家在看这部电影的时候，会有一种尹天仇和周星驰形象重叠的错觉，即尹天仇最终是一定会走向成功，会成为一个像星爷那般出色演员的错觉。假如尹天仇的成功是确定的，那么他现在所付出的种种努力无疑都是值得的。一个人若可以确定自己的努力一定会获得回报，那么对于自己的梦想的坚持会显得更为容易一些。但电影中的情况不一定是这样，尹天仇并不是星爷，他只是跑龙套的小人物，是个连想要个盒饭填饱肚子都会遭到场务羞辱的人，这个人物并不确定自己未来能否在演艺事业中取得成就，他或许一辈子都是个死跑龙套，一辈子都住在这昏黄的小屋，一辈子都在福利社兼职个小管理员，谁都无法确定（包括他自己）他现在所付出的努力一定会给他带来成功。所以，作为一个普通人，尹天仇眼神中有些愁闷和疑虑是正常的，他也有怀疑自己到底是不是演员这块料的时候。但是，面对一切都是未知， “漆黑一片” 的未来，他心中怀有希望 “天亮后便会好美的”，并且乐观面对生活。我们有时候会患得患失，怀疑自己现在坚持做的事到底有没有意义；有时候觉得长路漫漫目标那么遥远，觉得很疲倦很想放弃；有时候早上起来看着镜中的自己，也不知道自己的未来何去何从。我窃以为《喜剧之王》应该会是星爷最喜欢的电影，星爷在这部电影里彻彻底底的做了回自己。他可能想告诉观众很多，告诉他们演戏是多么的有趣多么的复杂，自己跑过龙套又演过主角，像过屎又轰轰烈烈过。但是到最后，星爷好像又不想讲这些了。对着那些看着电影或哭或笑的观众们，星爷整理了整理发型，给自己一个特写。 其实，他是一个演员。在这个日渐浮躁的社会里，轻易的谈论”梦想“二字逐渐变得尴尬，不是大家不再有梦想，而是大多数人不再相信梦想，以至于大多数人羞于谈梦想。但是，当你生于此世，不总归要有点梦想才有意思吗？《喜剧之王》就是告诉观者，拥有梦想和追逐梦想的意义，是那么重要。有没有那么一部分人会联想到自己？你也有梦想，也在为之追逐，你不远万里，背井离乡，在大城市孑然一身地奋斗，你租不起一千多的房子，稍好一点住隔断，次一点住地下室，你每天挤公交地铁，在一个公司当一个小职员只为填饱肚子，每天下班在路边吃麻辣烫，每个周末宅家里闭门不出，你穿着廉价衣服，吃着便宜饭菜，住着逼仄房子，你在很多人的眼里被冠以“屌丝”标签……但你有梦想，并且你也知道自己有梦想，并且愿意在生活如此艰难的情况下坚持追逐自己的梦想——你也是尹天仇。城市那么大，能者那么多，机会那么少，梦想都不小，生活艰不拆，是什么让你觉得自己活得至少还有点意义？《喜剧之王》告诉我们，不要做咸鱼，要做有梦想的人，即便是影片结尾，尹天仇依旧没能实现梦想，也还是显得伟大——梦想的意义，就在于你是否相信并为之努力，所有奋斗过的梦想，即使没有实现，也值得尊敬。《喜剧之王》在电影技术上，没有格外突出；在电影艺术上，也谈不上拔萃；但就是这样一部电影，在你看完之后，内心会为之深深触动——一个小人物的梦想，在浩瀚的生活面前，原来可以这么伟大。很多人喜欢这部电影，大抵也都是有所触动，或者产生了某些共鸣，这也正是《喜剧之王》值得人喜欢的地方。它几乎比很多号称爱情电影的电影更像爱情电影，因为它不仅讲述了一个爱情故事，还让这样一份爱情触动了很多人，以至于多年以后，人们提起这部电影的时候，会脱口而出那句经典的“我养你啊”。而本片最有泪点的一幕，或者说电影最伟大的一幕，则是这样一幅画面： 青春已不再,奋斗犹正时,此若不努力,枉为少年志.]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-博客2]]></title>
    <url>%2F2017%2F06%2F06%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A22%2F</url>
    <content type="text"><![CDATA[前期的初始化及基本路由的配置已经完成,主要是内容是模板的初始化设定.下面进行分模块开发和数据库等操作. 模块划分:根据功能进行模块划分:前台模块,后台管理模块,API模块(ajxa调用的一些接口)使用app.use()进行划分app.use(‘/admin’,require(‘./router/admin’));处理后台管理的urlapp.use(‘/api’,require(‘./router/api’));处理apiapp.use(‘/‘,require(‘./router/main’));处理前台展示 各js如main.js:var express=require(‘express’);var router=express.Router();//路由模块 ,监听app.js里以/admin开头的url. router.get(‘/‘,function(req,res,next){ res.send(‘首页’);}); module.exports =router; //将路由对象返回出去 安装数据库:npm(node包管理工具)的使用,第三方node模块的管理工具.开启mongodb数据库https://www/mongodb.com(貌似需要翻墙,请使用蓝灯)安装教程需要百度,其中安装里有一个选择custom方便以后查找安装位置.配置操作:mongod –dbpath=数据文件保存路径 –port=27018(端口)可视化工具安装http://blog.csdn.net/wrian_ban/article/details/51085678操作命令http://mongoosejs.com/第一次链接时候发现network is unreachable时请将localhost换成本机ip.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-博客1]]></title>
    <url>%2F2017%2F06%2F05%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A21%2F</url>
    <content type="text"><![CDATA[到了毕业季了,老师们也是有仇报仇有怨报怨,看着哪个不顺心的,使劲卡那个老师的学生毕业.大学教授虽然很多都是桃李芬芳,但总有那么几个没品没德的亲眼到学校参加了一场毕业答辩,背后真是暗流涌动啊. 网站架构就略去了 技术框架:Nodejs Express Mongodb 第三方模块&amp;中间件 bodyParser:解析post请求数据cookies:读写cookiesswig:模板解析引擎mongoose:操作mongodb数据markdown:markdown语法解析生成模块 操作:1:初始化 npm init2:安装框架npm install –save expresspackage.json的配置如下: { “name”: “blog2”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1” }, “author”: “”, “license”: “ISC”, “dependencies”: { “body-parser”: “^1.17.2”, “cookies”: “^0.7.0”, “express”: “^4.15.3”, “markdown”: “^0.5.0”, “mongoose”: “^4.10.4”, “swig”: “^1.4.2” }}3:目录结构db:数据库存储目录models:数据库模型文件目录node_modules:node第三方模块目录public:公共文件目录(css,js,image…)routers:路由文件目录schemas:数据库结构文件目录views:模板视图文件目录app.js:应用启动入口文件 4:编写app.js内容 处理请求输出:路由绑定:通过app.get()/app.post()等方法可以把一个url路径和一个或n个函数进行绑定app.get(‘/‘,function(req,res,next){})req:request对象-保存客户端请求相关的一些数据-http.requestres:response对象-服务端输出对象,提供了一些服务器端输出相关的一些方法next:方法,用于执行下一个和路径匹配的函数内容输出:通过res.send(string)发送内容至客户端 使用模板:后端逻辑和页面表现分离 var swig=require(‘swig’);app.engine(‘html’,swig.renderFile);定义模板引擎,使用swig,renderFile方法解析后置为html的文件app.set(‘views’,’./views’);设置模板存放目录app.set(‘view engine’,’html’)注册模板引擎swig.setDefaults({cache:false});取消缓存机制,不需要重启应用.原因: 当新建页面后必须重启应用,否则只会读取模板上次解析后存放在内存中的页面.这种缓存机制是为了提高页面的加载效率. app.use(‘/public’,express.static(__dirname+’/public’)) //设置静态文件托管//如果用户调用的文件是/public开头,则调用后面的方法去处理. 逻辑:用户发送http请求-&gt;url-&gt;解析路由-&gt;找到匹配的规则-&gt;执行绑定的函数-&gt;返回对应的内容至用户. /public -&gt;静态文件 -&gt;直接读取指定目录下的文件-&gt;返回给用户 动态-&gt;处理业务逻辑,加载模板,解析模板-&gt;返回数据给用户代码如下:var express= require(‘express’); //加载模块var swig=require(‘swig’);//加载模板处理模块var mongoose=require(‘mongoose’);//加载数据库模块var app=express();//创建app应用 等同于node.js http.createServer(); app.use(‘/public’,express.static( __dirname+’/public’)) //设置静态文件托管//如果用户调用的url文件是/public开头,则调用后面的方法去处理.返回其文件 app.engine(‘html’,swig.renderFile);//定义当前应用所使用的模板引擎//第一个参数:模板引擎的名称,同事也是模板文件的后缀//第二个参数,用于解析处理模板内容的方法 app.set(‘views’,’./views’);//第一个参数必须是views .第二个参数是目录 app.set(‘view engine’,’html’);//第一个参数必须是 view engine,第二个参数和app,engine方法中定义的模板引擎名称(第一个参数)必须相同! swig.setDefaults({cache:false}); app.get(‘/‘,function(req,res,next){ // res.send(‘欢迎光临我的博客’) //读取views目录下的指定文件,并解析返回给客户端 res.render(‘index’); //第一个参数:表示模板的文件,相当于views目录下的文件index.html.(可以自定义新建这个页面) //第二个参数:传递给模板使用的数据.})mongoose.connect();app.listen(8081);//监听http请求]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站页面优化]]></title>
    <url>%2F2017%2F06%2F01%2F%E7%BD%91%E7%AB%99%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[经常在群里活跃,有不少面试的同仁在回答面试或者笔试的时候会问到这个.本着求根问底的精神,在网上找了一些资料,现整理如下以后还会继续补充一.页面优化1.HTTP优化 只要是请求就必然有成本,时间成本资源成本等,一个完整的请求需要经过DNS寻址,与服务器建立连接,发送数据,等待服务器响应,接受数据这样一个漫长负责的过程.而请求所带的数据需要占用带宽,而浏览器进行并发请求的请求书是有上限的,所以这样必然会导致浏览器需要分批处理,从而用户等待时间变长.(1).减少请求数,例如百度首页. (2).合理设置HTTP缓存,原则就是缓存越多越久越好. (3).css和js都可以压缩合并,甚至包括图片,压缩工具请百度~ (4).css sprites 合并图片,将图片集中在一个大图上. (5).Inline Image,使用data: URL scheme的方式将图片嵌入到页面或CSS中,虽然说的很高大上,其实就是用Base64位码. 2.脚本优化(1).将外部脚本置底.浏览器是可以并发请求的,但是js脚本却是单线程的,所以外链脚本在加载时会阻塞其他资源,所以可以按照需求将脚本适当的置于靠后的部分.外链脚本:静态资源库http://cdn.code.baidu.com/ (2).异步执行inline脚本(网页上部引用的本地脚本).inline脚本在执行的时候一样阻塞并发请求,而浏览器页面处理方面是单线程的,从上到下依次渲染.建议是进行异步处理,Html5引用web worker机制解决问题.a.普及 web worker(工作线程):允许开发人员编写狗狗长时间运行而不被用户所 中断的后台在程序,去执行事务或者逻辑并同时保证页面对用户的响应.简而言之就是允许JS创建多个线程,但是子线程完全受主线控制,且不得操作DOM. (3).lazy load js.一种是为那些流量特别大的页面专门定制一个专用的mini版框架，另一种则是Lazy Load。YUI则使用了第二种方式，在YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载 (4).将CSS放在HEAD中. (5).异步请求Callback. 二 seo引擎优化增强搜索引擎营销的效果使网站的产品相关的关键词能有好的排位。使网站更容易被搜索引擎收录，提高用户体验和转化率进而创造价值.(1).网站重构.就是将所有的字体、样式等表现形式都写成DIV+CSS的方式，CSS放在单独文件里，Javascript也放在单独文件，HTML里面只有文字内容。凡是可以使用外部文件调用的，就使用外部文件调用，可以不出现的，尽量不出现，在正文中，全部以文字为主，不要出现CSS代码。这样做的好处是，HTML文件的代码被精简，文件变小，搜索引擎在索引网站页面时，可以更好地索引和识别网站的内容信息，并能准确抓取页面正文的内容。 (2).Meta标签优化.对于Meta标签，主要有title、description、keywords三个地方，其余的meta标签不加也没事。就重要性而言，title在页面优化中绝对占据很重要的位置。title标题标签告诉用户和搜索引擎一个特定网页的主题是什么。标签通常放在HTML文档的标签内。理想情况下，应该为网站的每一个网页创建唯一的title页面标题。关于title的写作，title标签应该准确描述网页的内容，使用简短的，但具描述性的标题标签——短的标题同样可以包含丰富的信息。如果标题太长，搜索引擎只会在搜索结果里显示其部分内容。尽量不要堆积太多关键词，如果是长标题，可以包含关键词1-2次，而且关键词不用靠的太近。description描述标签提供了关于这个网页的总括性描述，网页的标题可能是由一些单词和短语组成的，而网页的描述元标签则常常是由一两个语句或段落组成的。如果网页摘要里的某个词语恰好出现在用户的查询里，那么这个词语将被高亮显 示，如果描述标签写的好，可以提升页面的点击率。关于description的写作，description标签准确概括该网页的内容，每一个网页应该创建各不相同的描述标签，避免所有的网页或很多网页使用千篇一律的description标签。keywords关键词标签，对于页面优化来说，重要性已经大不如前，甚至有种说法是，keywords标签已经没用了，不过，就算搜索引擎已经不将keywords考虑进，写一下keywords标签可能还会有些作用，不过keywords里面不要堆砌太多关键字，否则可能适得其反，写上4、5个核心关键字即可。 (3).Heading标签优化. Heading标签（H标签）通常用来为用户呈现网页的结构。HTML语言里一共有六种大小的H标签，从最重要的H1到H6，权重依次降低。最常用的包括H1、H2标签，H1代表着大标题，H2是小标题。按照这个意思，最重要的关键词设置在H1标签中，和关键词相关的词组再放到H2标签中，依次往后推。 (4).Alt优化. 图片的优化对于网站页面来说也非常重要，所有的图片都拥有一个Alt属性，对于图片的优化主要是针对这个属性的优化，优化图片的alt属性可以使得图片搜索引擎能更好地理解图片。 (5).链接锚文本优化.锚文本是链接上可以被点击的文字，它通常被放在锚标记A标签中间，锚文本主要作用是描述链接页面的一些情况，锚文本写得越好，用户浏览网站就越容易，搜索引擎也能更容易地理解链接到的页面内容。 (6).关键词优化.关键词的布局，最重要的几个位置是开头，特别是第一段开头的50-150个字，需要包含一次关键词，然后中间正文中，出现2-3次关键词或者近义词，文章的结尾，也包含一次关键词就可以了。关键字密度有时候会影响到关键词的排名，不建议采取一些极端的方法来提高关键字密度。合理的目标关键字密度可以通过关注一些长尾关键字来进行优化。长尾关键词(Long Tail Keyword)是指网站上非目标关键词但也可以带来搜索流量的关键词。长尾关键词的特征是比较长，往往是2-3个词组成，甚至是短语。通过长尾关键词挖掘工具可以找到不少长尾关键词，将这些词组织到文章里，就可以做到既不提高关键词密度，又能提升关键词在页面的权重。 (7).内容优化. 1、撰写容易阅读，浅显易读的内容，有条理地组织内容，段落清晰，让读者能够清楚地了解内容的起始和逻辑，避免将大量不同主题的内容放在同一页上，却没有任何的分段、标识和层次划分。2、提供原创的、独特新颖的内容，不要模仿甚至抄袭别人的内容。原创内容不仅仅能吸引更多的用户，还可以招揽更多的回头客。而搜索引擎对于原创内容的识别能力也越来越高。三.代码优化未完待续http://blog.csdn.net/li2274221/article/details/25193381没有细看,但是很多内容很不错.]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>网页优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-6]]></title>
    <url>%2F2017%2F06%2F01%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-6%2F</url>
    <content type="text"><![CDATA[程序员不易,坐久了腰好疼啊~继续开始使用node.js进行web开发 http://www.baidu.com请求后动作1.浏览器发送http请求,请求指定的baidu.com的主机(DNS解析IP地址)2.该ip地址的设备接受到请求后会对该请求进行分析和处理.3.服务器处理完成后,返回对应的数据到用户浏览器.4.浏览器接受把服务器返回的数据,然后进行分析处理.渲染等操作. var http=require(‘http’);//通过http模块下的createserver创建并返回一个web服务器对象.var server=http.createServer(); //监听端口.端口:网络数据交互如QQ等数据的传输和发送都需要通过网卡,划分好对应的’分机’才能对应监听//一个应用程序可以监听多个端口数据,一个端口数据只能被一个应用监听.//server.listen(port,[hostname],[backlog],[callback])//port:监听端口.// hostname:主机名(Ip/域名).// backlog:连接等待队列的最大长度.(允许多少客户端等待)// callback:调用listen方法并成功开启监听后,//会触发一个listning事件,callback将作为该事件的执行函数.//端口号1-1024 给系统使用,server.on(‘error’,function(err){ //服务开启失败时触发 console.log(err);}) server.on(‘listening’,function(){ //调用listen方法时触发 console.log(‘listen’); })server.on(‘request’,function(req,res){ //有客户端发送请求到该主机和端口的请求的时候触发 console.log(‘有请求了’); //req:存储跟客户端发送请求的相关信息 // console.log(req); //res:服务端数据处理,向客户端发送指定的数据 res.write(‘hello’); //(chuank,encoding):发送一个数据块到响应正文中,后面是编码方式. res.end(); //(chuank,encoding):当所有的正文和头信息发送完成以后会调用该方法告诉 // 服务器数据已经全部发送完成,这个方法在每次完成信息发送以后必须调用,并且是最后调用.})res.writeHead(200,’dddd’,{ //浏览器接受到的永远都是字符串,会根据header里的类型进行设置. ‘content-type’:’text/html’, }) ;server.listen(8089,’localhost’); //浏览器输入 http://localhost:8089/ request方法就会有响应. //////////////////////////////////////// var http=require(‘http’); var url=require(‘url’);var server=http.createServer();(var fs=require(‘fs’);)server.on(‘request’,function(req,res){ var urlStr=url.parse(req.url); (var htmlDir=_dirname+’/html’;) console.log(urlStr);//将url解析成一个json对象进行查看. switch (urlStr.pathname){ case ‘/‘: ( sendData(htmlDir+’index.html’,req,res)) res.writeHead(200,{ //可以使用fs模块实现分离 ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘shouye’); break; case ‘/user’: res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘geren’); break; default: res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘beichidiao’); break; } console.log(req.url);//访问路径; ?后面的部分query string 查询字符串}) ;function sendData(file,req,res){fs.readFile(file,function(err,data){if(err){ res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘shouye’);}else{ res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘data’);}})}server.listen(8080,’localhost’); log:Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: ‘?=1’, query: ‘=1’, pathname: ‘/a’, path: ‘/a?=1’, href: ‘/a?=1’ }/a?=1 //////////////////////////////////////// urlStr里有query的值即是提交的表单Query.String: 序列化一个对象到一个query string 可以选择是否覆盖默认的分分割符(‘&amp;’)和分配符(‘=’).也可以自定义 eg:username=ab&amp;password=123 Query.parse:反序列化]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-5]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-5%2F</url>
    <content type="text"><![CDATA[本章开始学习前端项目自动化包括项目构建,自动合并等话不多说 继续开始fs模块介绍http://www.jianshu.com/p/5683c8a93511PS:{}和[]有啥区别?答案是{}里面是对象,[]则是数组 ///////////////////////////// 初始化文件项目 var projectData={ ‘name’:’miaov’, ‘fileData’:[ { ‘name’:’css’, ‘type’:’dir’ }, { ‘name’:’js’, ‘type’:’dir’ }, { ‘name’:’images’, ‘type’:’dir’ }, { ‘name’:’index.html’, ‘type’:’file’, ‘content’:’\n\t\n\t\ttitle\n\t\n\t\n\t\thello\n\t\n‘, } ] }; if(projectData.name){ fs.mkdirSync(projectData.name); var fileData=projectData.fileData; if(fileData &amp;&amp; fileData.forEach){ fileData.forEach(function(f){ f.path= projectData.name+’/‘+ f.name; f.content= f.content || ‘’; switch (f.type) { case ‘dir’: fs.mkdirSync(f.path); break; case ‘file’: fs.writeFileSync(f.path, f.content); break; } }) } } /////////////////////////////]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-4]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-4%2F</url>
    <content type="text"><![CDATA[生活不易,且行且珍惜.忙活了三天,电脑没碰,生活上的事情焦头烂额,继续吧.上次的学习主要是fs文件模块的使用,包括fs.write,fs.open,fs.read等.日常错误就是对其读写操作属性的配置.下面继续开始下一章. fs.readFile(filename,[options],callback)//异步读取一个文件的全部内容 fs.readFileSync(filename,[options])//同步 fs.unlink(filename,callback)//异步删除一个文件 fs.unlinkSync(path)//同步 fs.rename(‘oldname’,’newname’,callback)//重命名 fs.stat(path.callback)//读取文件信息(属性) { ‘0’: null, ‘1’: Stats { dev: 826654, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 60517119993054080, size: 17, blocks: undefined, atime: 2017-05-27T08:29:26.420Z, mtime: 2017-05-27T08:45:50.850Z, ctime: 2017-05-27T08:45:50.850Z, birthtime: 2017-05-27T07:51:00.935Z } } fs.watch(filename,[options],[listener])//不稳定,观察指定路径的改版 回调函数里的参数(event,filename)监听内容及命名的变化 (change,rename)event 为rename表示指定的文件或目录中有重命名、删除或移动操作或change表示有修改，filename表示发生变化的文件路径///////////////////////////// 下面是操作文件夹的一些内容fs.mkdir(path,[mode],callback) //创建文件夹fs.mkdir(‘./1’,function(){ console.log(arguments);//0:null})fs.mkdirSync(path,[mode])//同步版本 fs.readdir(path,callback)//读取文件夹fs.readdir(‘../learnnode’,function(err,fileList){ fileList.forEach(function(f){ fs.stat(f,function(err,info){ switch (info.mode){ case 16822: console.log(‘文件夹’+f); break; case 33206: console.log(‘文件’+f); break; default: console.log(f); break; } }) })}) readdir(‘../learnnode’,function(err,fileList){ fileList.forEach(function(f){ fs.stat(f,function(){ console.log(arguments); }) })})输出:{ ‘0’: null, ‘1’: Stats { dev: 826654, mode: 16822, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 3940649674220553, size: 0, blocks: undefined, atime: 2017-05-31T02:35:17.146Z, mtime: 2017-05-31T02:35:17.146Z, ctime: 2017-05-31T02:35:17.146Z, birthtime: 2017-05-31T02:35:17.146Z } }{ ‘0’: null, ‘1’: Stats { dev: 826654, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 14355223812513196, size: 6, blocks: undefined, atime: 2017-05-27T07:16:26.216Z, mtime: 2017-05-27T07:16:30.209Z, ctime: 2017-05-27T07:16:30.209Z, birthtime: 2017-05-27T06:24:41.427Z } } 注意!mode 33206代表文件,16822代表文件夹fs.readdirSync(path)//同步版本 fs.rmdir(path,callback)//删除文件夹 fs.rmdir(path)//同步版本 /////////////////////////////]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-3]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[花了一上午，在领导的指示下做了一个手机端的界面http://zhaopin.yanhuatong.com/挺丑，也就只能这样了，哈哈下午打卡，话不多说，开始吧上次学了点Buffer的指示,其实主要还是字符的拼接切割,但是又涉及到IO的操作.重点:Buffer会占用内存,写入后不会轻易更改.类方法,静态方法什么是静态方法?我也没理解透,查阅了一些资料↓静态方法也叫类方法:类方法属于类，使用时不需要实例化一个对象，直接使用类名称就可以使用。(在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。)成员方法也叫对象方法:对象方法属于某个对象实例，必须先有一个对象，才可以使用(实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。) ///////////////////////////// console.log(Buffer.isEncoding(‘utf-8’))//true console.log(Buffer.byteLength(‘utf-8’))//5 console.log(Buffer.byteLength(‘妙味’)) //6var str=’miaov’;var str2=’妙味’;var list=[new Buffer(str),new Buffer(str2)];console.log(list);//[ , ] var bf=Buffer.concat(list);console.log(bf);//var str3= bf.toString();console.log(str3);//miaov妙味//如果在输出的时候使用字符串拼接(‘xxxx’+str)会自动转化为字符串而不需要toString ///////////////////////////// File System -文件系统模块 使用方法 :require(‘fs’) fs.open(path,flags,[mode],callback);(异步,不耽误后续动作执行)path:要打开文件的路径;flags:打开文件的方式,常用的:读/写;mode:设置文件的模式:读/写/执行 4/2/1;callback:回调 err:文件打开失败的错误保存在err里面,如果成功err为Null. fd:被打开文件的标识. fs.opnSync(path,flags,[mode]);(同步,无回调函数) ///////////////////////////// fs.read(fd,buffer,offset,length,position,callback);//从指定文档标识符fd读取文件数据.fd:通过open方法成功打开一个文件返回的编号.buffer:buffer对象offset:偏移量,新的内容添加到buffer中的起始位置length:添加到buffer中内容的长度position:读取的文件中的起始位置callback:回调函数:参数有err newbuflength(长度) newbf(更改后的buffer) var bf1=new Buffer(10); console.log(bf1); fs.read(fd,bf1,0,4,null,function(err){ console.log(bf1);//// ///////////////////////////// fs.write(fd,buffer,offset,length,position,callback);fd:打开的文件buffer:要写入的数据offset:buffer对象中要 写入的数据的起始位置length:要写入的Buffer数据的长度postition:fd中起始位置callback:回调offset和position的区别是什么?offset是指new Buffer(‘123’);里的偏移量position是指fd文件被修改的起始位置 var fs=require(‘fs’); fs.open(‘1.text’,’r’,function (err,fd){ if(err){ console.log(err); } else { /*var bf1=new Buffer(10); console.log(bf1); fs.read(fd,bf1,0,4,null,function(err){ console.log(bf1); }) */ var bf=new Buffer(&apos;123&apos;); fs.write(fd,bf,0,3,0,function(){ console.log(arguments); }) } })//会报错,那是为什么呢?报错如下{ ‘0’: { Error: EPERM: operation not permitted, write at Error (native) errno: -4048, code: ‘EPERM’, syscall: ‘write’ }, ‘1’: 0, ‘2’: }注意:我们回头看起,Buffer有读写操作,当我们以只读的时候打开就无法进行写的操作 所以上面的应该改为:fs.open(‘1.text’,’r+’,function (err,fd){ fs.write(fd,’1234数据’,[encoding编码方式],callback);直接添加字符串 fs.close(fd,callback);关闭打开文件 ,无法进行后续操作. ///////////////////////////// fs.writeFile(filename,data,[options],callback)异步的将数据写入一个文件,如果文件不存在则新建,如果文件原来存在,则会被替换.data:可以是一个string,也可以是一个原生buffer.var fs=require(‘fs’);var filename=’2.txt’; fs.writeFile(filename,’hello’,function(){ console.log(arguments); }); fs.appendFile(filename,data,[options],callback)异步的将数据添加到一个文件的尾部,如果文件不存在,会创建一个新的文件,data同上.fs.appendFile(filename,’leo’,function(){})fs.appendSync(filename,data,options) 同步模式无返回值!!!fs.exists(filename,function(err){})//检测文件是否存在,true/false同步模式:var fs=require(‘fs’);var filename=’2.txt’; if(!fs.existsSync(filename)){ fs.writeFileSync(filename,’miaov’); console.log(‘xinzengchenggong’) }else{ fs.appendFileSync(filename,’-leo’); console.log(‘zhuijiachenggong’) } 为什么在检测的时候要用同步? 因为同步模式直接返回true,或者false,如果要用异步模式则需要调用callback.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-2]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[小张来打卡了,这是第二天了,忙活了一上午的数据库,总算成功的导入了.现在可以沉下心来接着看了昨天学习了一些基础的知识,主要还是require和exports的机制.今天努努力开始继续学习吧.ready go! 有点尴尬么 哈哈~http://oqfuveidu.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170526132504.jpg ///////////////////////////////console.log(_filename);返回当前模块文件的解析后的绝对路径,该属性其实并非全局的,而是模块作用域下的.//console.log(_dirname);返回当前模块文化部所以在目录解析后的绝对路径,该属性也不是全局的,而是模块作用域下的.效果如下:d:\learnnode\6.jsd:\learnnode ///////////////////////////// global:process对象process对象是一个全局对象,可以在任何地方都能访问到,通过这个对象提供的属性和方法, 使我们可以对当前运行的程序的进程进行访问和控制.process.argv:一个包含命令行参数的数组,第一个元素是node,第二个元素是.js文件名称.接下来的元素一次是命令行传入的参数. console.log(process.pid);可以进入资源管理器查看PID:任务进程编号 process.stdin,stdout :标准输入输出流(IO),提供操作输入数据和输出数据的方法 process.stdin.resume();//默认情况下,输入流是关闭的,要监听处理输入流数据,首先要开启输入流.process.stdin.on(‘data’,function(chunk) { console.log(‘yonghushuru’+chunk);});//用于监听用户输入数据 ///////////////////////////// Buffer类:一个用于 更好操作二进制数据的类(全局类) var bf=new Buffer(5);//size[num]创建一个Buffer对象,并未这个对象分配一个大小,当分配空间大小后,其长度固定,无法更改.console.log(bf);//var bf=new Buffer([1,2,3]);console.log(bf);//var bf=new Buffer(‘miaowei’,’utf-8’);//把字符串转成二进制数据,默认utf8console.log(bf);// for(var i=0;i&lt;bf.length;i++){ //bf.length指字节长度,而不是字符串长度.而在utf8编码中一个汉字占3个字节,一个字母或者数字占一个字节. console.log(String.fromCharCode(bf[i]));}//反向输出字符 buf.write():从指定的字符串当中以指定的编码写入指定长度字符.var str=”miaovvvvvv”;var bf=new Buffer(5);bf.write(str) ;console.log(bf);//bf.write(str,1,3) ; 1:偏移量(从对象的第几位开始写入,从0开始),3:指长度.console.log(bf);// var bf=new Buffer(‘miaov’);console.log(bf.toString(‘utf-8’,1,3));//ia var bf2=new Buffer(‘妙味’);console.log(bf2.toString(‘utf-8’,1));//��味 console.log(bf2.toJSON());//{ type: ‘Buffer’, data: [ 229, 166, 153, 229, 145, 179 ] }调用字符串序列号这个实例 slice(2,4);引用相同的内存地址,然后进行切割成新的字节数组buffer.bf.copy(bf4);输出bf4的Buffer值 今天完结,明天继续.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-1]]></title>
    <url>%2F2017%2F05%2F25%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[作为一个刚刚入行的小白,在学习vue.js的这种进阶的知识后发现自己还欠了很多的基础内容.在思考了很久之后我决定补一下这些知识,一步一个坎,总要踩过去.那么又面临一个问题.node.js和html5 一个偏后端一个偏前端该选择哪个呢?我很纠结在思考了一个上午后我觉得我还是需要先学node.js.为什么要学它.我的理由很简单:node.js是一门可以处理后端的技术,这样我就不用学习.net c#一类的了.哈哈…原文地址:https://www.zhihu.com/question/33578075如果有人不懂为什么要学习node.js可以看下上面的链接.视频的学习链接请百度网易云课堂不是打广告计划一个月的时间学习它.那么开始吧~Js组成: 操作浏览器 Ecmascript+BOM+DOM node.js: 操作系统网络等 Ecmascript os file net database相同点:在ECMAScript部分node和js其实是一样的,比如数据类型的定义,语法结构,内置对象等等差异性:顶层对象 js:window node:没有window概念,有global全局对象node:var a=100;console.log(global.a)//undefined//模块化:一个文件就是一个模块,每一个模块都有自己的作用域.//我们使用var来声明一个定义,他并不是全局的,而是属于当前模块下. global.a=200;console.log(a);//100console.log(global.a);//200 在一个模块下定义的变量,其作用域只是当前模块,外部无法调用. 如果想一个模块能够访问另外一个模块中定义的变量,可以: 1.把变量作为global对象的一个属性(不推荐). 2.使用模块对象module:保存提供和当前模块有关的一些信息. console.log(module); Module { id: ‘.’, exports: {}, parent: null, filename: ‘d:\learnnode\4.js’, loaded: false, children: –&gt;加载的模块 [ Module { id: ‘d:\learnnode\5.js’, exports: {}, parent: [Circular], filename: ‘d:\learnnode\5.js’, loaded: true, children: [], paths: [Object] } ], paths: [ ‘d:\learnnode\node_modules’, ‘d:\node_modules’ ] } //在这个module对象,有一个子对象:exports对象,我们可以通过这个对象把//一个模块中的局部变量对象进行提供访问.module.xeports.a=a;var m5= require(‘./5’);//这个方法的返回值,其实就是被加载模块中的module.exports 在模块作用域,还有一个内置的模块对象:exports,他其实就是module.exports. 注意:module.exports=[1,2,3];//expors和module.exports的指向关系会断开,导致exports的输出错误. 在已有的属性进行添加,而不是重写. //_filename:当前文件被解析过后的绝对路径.属于当前模块下的.//模块加载系统:require(‘模块’); eg: require(‘./2.js’); //模块加载机制: 路径 绝对路径:require(‘b:/x/x/2.js’); 相对路径:require(‘./2.js’);//未加./会加载node的核心模块,或者是node_modules require(&apos;./2&apos;)// 1.首先按照加载的模块的文件名称进行查找 2.如果没有找到,则会在模块文件名称后面加上.js的后缀,进行查找. 3.如果还么有找到,则会在文件名称后面加上.json的后缀,进行查找. 4.如果还没有找到,则会在文件名称后面加上.node的后缀,进行查找. 5.还为找到,抛出错误.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F05%2F24%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我在Github上第一次搭建博客.遇到了很多的困难也得到了很多的帮助,如果你也想搭建一个这样的博客,不妨参考下这个帮助:https://fzy-line.github.io/ 如果你遇到了在分类和标签上出现无法加载的情况,请不要着急,在你生成的页面后进入/sourse/tags里加入layout: “tags”. 下面是网站的发布流程:新建博客 $ hexo new “我的第一篇博客”到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。 编辑博客 Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下： title: 我的第一篇博客date: 2016-12-02 23:44:20 tags: #文章标签 可以省略tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做： tags: [Linux,Http,网络]我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如： categories: Linux 发布博客 $ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 $ hexo generate #生成静态页面至public目录写好之后可以现在本地预览，确定无误之后再部署到Github上。 $ hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） $ hexo deploy #将.deploy目录部署到GitHub需要说明的是： 我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。 hexo命令简写形式 hexo n “我的博客” == hexo new “我的博客”hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
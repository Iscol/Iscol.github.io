<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于node.js的学习-博客1]]></title>
    <url>%2F2017%2F06%2F05%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A21%2F</url>
    <content type="text"><![CDATA[到了毕业季了,老师们也是有仇报仇有怨报怨,看着哪个不顺心的,使劲卡那个老师的学生毕业.大学教授虽然很多都是桃李芬芳,但总有那么几个没品没德的亲眼到学校参加了一场毕业答辩,背后真是暗流涌动啊. 网站架构就略去了 技术框架:Nodejs Express Mongodb 第三方模块&amp;中间件 bodyParser:解析post请求数据cookies:读写cookiesswig:模板解析引擎mongoose:操作mongodb数据markdown:markdown语法解析生成模块 操作:1:初始化 npm init2:安装框架npm install –save expresspackage.json的配置如下: { “name”: “blog2”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1” }, “author”: “”, “license”: “ISC”, “dependencies”: { “body-parser”: “^1.17.2”, “cookies”: “^0.7.0”, “express”: “^4.15.3”, “markdown”: “^0.5.0”, “mongoose”: “^4.10.4”, “swig”: “^1.4.2” }}3:目录结构db:数据库存储目录models:数据库模型文件目录node_modules:node第三方模块目录public:公共文件目录(css,js,image…)routers:路由文件目录schemas:数据库结构文件目录views:模板视图文件目录app.js:应用启动入口文件 4:编写app.js内容 处理请求输出:路由绑定:通过app.get()/app.post()等方法可以把一个url路径和一个或n个函数进行绑定app.get(‘/‘,function(req,res,next){})req:request对象-保存客户端请求相关的一些数据-http.requestres:response对象-服务端输出对象,提供了一些服务器端输出相关的一些方法next:方法,用于执行下一个和路径匹配的函数内容输出:通过res.send(string)发送内容至客户端 使用模板:后端逻辑和页面表现分离 var swig=require(‘swig’);app.engine(‘html’,swig.renderFile);定义模板引擎,使用swig,renderFile方法解析后置为html的文件app.set(‘views’,’./views’);设置模板存放目录app.set(‘view engine’,’html’)注册模板引擎swig.setDefaults({cache:false});取消缓存机制,不需要重启应用.原因: 当新建页面后必须重启应用,否则只会读取模板上次解析后存放在内存中的页面.这种缓存机制是为了提高页面的加载效率. app.use(‘/public’,express.static(__dirname+’/public’)) //设置静态文件托管//如果用户调用的文件是/public开头,则调用后面的方法去处理. 逻辑:用户发送http请求-&gt;url-&gt;解析路由-&gt;找到匹配的规则-&gt;执行绑定的函数-&gt;返回对应的内容至用户. /public -&gt;静态文件 -&gt;直接读取指定目录下的文件-&gt;返回给用户 动态-&gt;处理业务逻辑,加载模板,解析模板-&gt;返回数据给用户代码如下:var express= require(‘express’); //加载模块var swig=require(‘swig’);//加载模板处理模块var app=express();//创建app应用 等同于node.js http.createServer(); app.use(‘/public’,express.static( __dirname+’/public’)) //设置静态文件托管//如果用户调用的url文件是/public开头,则调用后面的方法去处理.返回其文件 app.engine(‘html’,swig.renderFile);//定义当前应用所使用的模板引擎//第一个参数:模板引擎的名称,同事也是模板文件的后缀//第二个参数,用于解析处理模板内容的方法 app.set(‘views’,’./views’);//第一个参数必须是views .第二个参数是目录 app.set(‘view engine’,’html’);//第一个参数必须是 view engine,第二个参数和app,engine方法中定义的模板引擎名称(第一个参数)必须相同! swig.setDefaults({cache:false}); app.get(‘/‘,function(req,res,next){ // res.send(‘欢迎光临我的博客‘) //读取views目录下的指定文件,并解析返回给客户端 res.render(‘index’); //第一个参数:表示模板的文件,相当于views目录下的文件index.html.(可以自定义新建这个页面) //第二个参数:传递给模板使用的数据.}) app.listen(8081);//监听http请求]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站页面优化]]></title>
    <url>%2F2017%2F06%2F01%2F%E7%BD%91%E7%AB%99%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[经常在群里活跃,有不少面试的同仁在回答面试或者笔试的时候会问到这个.本着求根问底的精神,在网上找了一些资料,现整理如下以后还会继续补充一.页面优化1.HTTP优化 只要是请求就必然有成本,时间成本资源成本等,一个完整的请求需要经过DNS寻址,与服务器建立连接,发送数据,等待服务器响应,接受数据这样一个漫长负责的过程.而请求所带的数据需要占用带宽,而浏览器进行并发请求的请求书是有上限的,所以这样必然会导致浏览器需要分批处理,从而用户等待时间变长.(1).减少请求数,例如百度首页. (2).合理设置HTTP缓存,原则就是缓存越多越久越好. (3).css和js都可以压缩合并,甚至包括图片,压缩工具请百度~ (4).css sprites 合并图片,将图片集中在一个大图上. (5).Inline Image,使用data: URL scheme的方式将图片嵌入到页面或CSS中,虽然说的很高大上,其实就是用Base64位码. 2.脚本优化(1).将外部脚本置底.浏览器是可以并发请求的,但是js脚本却是单线程的,所以外链脚本在加载时会阻塞其他资源,所以可以按照需求将脚本适当的置于靠后的部分.外链脚本:静态资源库http://cdn.code.baidu.com/ (2).异步执行inline脚本(网页上部引用的本地脚本).inline脚本在执行的时候一样阻塞并发请求,而浏览器页面处理方面是单线程的,从上到下依次渲染.建议是进行异步处理,Html5引用web worker机制解决问题.a.普及 web worker(工作线程):允许开发人员编写狗狗长时间运行而不被用户所 中断的后台在程序,去执行事务或者逻辑并同时保证页面对用户的响应.简而言之就是允许JS创建多个线程,但是子线程完全受主线控制,且不得操作DOM. (3).lazy load js.一种是为那些流量特别大的页面专门定制一个专用的mini版框架，另一种则是Lazy Load。YUI则使用了第二种方式，在YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载 (4).将CSS放在HEAD中. (5).异步请求Callback. 二 seo引擎优化增强搜索引擎营销的效果使网站的产品相关的关键词能有好的排位。使网站更容易被搜索引擎收录，提高用户体验和转化率进而创造价值.(1).网站重构.就是将所有的字体、样式等表现形式都写成DIV+CSS的方式，CSS放在单独文件里，Javascript也放在单独文件，HTML里面只有文字内容。凡是可以使用外部文件调用的，就使用外部文件调用，可以不出现的，尽量不出现，在正文中，全部以文字为主，不要出现CSS代码。这样做的好处是，HTML文件的代码被精简，文件变小，搜索引擎在索引网站页面时，可以更好地索引和识别网站的内容信息，并能准确抓取页面正文的内容。 (2).Meta标签优化.对于Meta标签，主要有title、description、keywords三个地方，其余的meta标签不加也没事。就重要性而言，title在页面优化中绝对占据很重要的位置。title标题标签告诉用户和搜索引擎一个特定网页的主题是什么。标签通常放在HTML文档的标签内。理想情况下，应该为网站的每一个网页创建唯一的title页面标题。关于title的写作，title标签应该准确描述网页的内容，使用简短的，但具描述性的标题标签——短的标题同样可以包含丰富的信息。如果标题太长，搜索引擎只会在搜索结果里显示其部分内容。尽量不要堆积太多关键词，如果是长标题，可以包含关键词1-2次，而且关键词不用靠的太近。description描述标签提供了关于这个网页的总括性描述，网页的标题可能是由一些单词和短语组成的，而网页的描述元标签则常常是由一两个语句或段落组成的。如果网页摘要里的某个词语恰好出现在用户的查询里，那么这个词语将被高亮显 示，如果描述标签写的好，可以提升页面的点击率。关于description的写作，description标签准确概括该网页的内容，每一个网页应该创建各不相同的描述标签，避免所有的网页或很多网页使用千篇一律的description标签。keywords关键词标签，对于页面优化来说，重要性已经大不如前，甚至有种说法是，keywords标签已经没用了，不过，就算搜索引擎已经不将keywords考虑进，写一下keywords标签可能还会有些作用，不过keywords里面不要堆砌太多关键字，否则可能适得其反，写上4、5个核心关键字即可。 (3).Heading标签优化. Heading标签（H标签）通常用来为用户呈现网页的结构。HTML语言里一共有六种大小的H标签，从最重要的H1到H6，权重依次降低。最常用的包括H1、H2标签，H1代表着大标题，H2是小标题。按照这个意思，最重要的关键词设置在H1标签中，和关键词相关的词组再放到H2标签中，依次往后推。 (4).Alt优化. 图片的优化对于网站页面来说也非常重要，所有的图片都拥有一个Alt属性，对于图片的优化主要是针对这个属性的优化，优化图片的alt属性可以使得图片搜索引擎能更好地理解图片。 (5).链接锚文本优化.锚文本是链接上可以被点击的文字，它通常被放在锚标记A标签中间，锚文本主要作用是描述链接页面的一些情况，锚文本写得越好，用户浏览网站就越容易，搜索引擎也能更容易地理解链接到的页面内容。 (6).关键词优化.关键词的布局，最重要的几个位置是开头，特别是第一段开头的50-150个字，需要包含一次关键词，然后中间正文中，出现2-3次关键词或者近义词，文章的结尾，也包含一次关键词就可以了。关键字密度有时候会影响到关键词的排名，不建议采取一些极端的方法来提高关键字密度。合理的目标关键字密度可以通过关注一些长尾关键字来进行优化。长尾关键词(Long Tail Keyword)是指网站上非目标关键词但也可以带来搜索流量的关键词。长尾关键词的特征是比较长，往往是2-3个词组成，甚至是短语。通过长尾关键词挖掘工具可以找到不少长尾关键词，将这些词组织到文章里，就可以做到既不提高关键词密度，又能提升关键词在页面的权重。 (7).内容优化. 1、撰写容易阅读，浅显易读的内容，有条理地组织内容，段落清晰，让读者能够清楚地了解内容的起始和逻辑，避免将大量不同主题的内容放在同一页上，却没有任何的分段、标识和层次划分。2、提供原创的、独特新颖的内容，不要模仿甚至抄袭别人的内容。原创内容不仅仅能吸引更多的用户，还可以招揽更多的回头客。而搜索引擎对于原创内容的识别能力也越来越高。三.代码优化未完待续http://blog.csdn.net/li2274221/article/details/25193381没有细看,但是很多内容很不错.]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>网页优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-6]]></title>
    <url>%2F2017%2F06%2F01%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-6%2F</url>
    <content type="text"><![CDATA[程序员不易,坐久了腰好疼啊~继续开始使用node.js进行web开发 http://www.baidu.com请求后动作1.浏览器发送http请求,请求指定的baidu.com的主机(DNS解析IP地址)2.该ip地址的设备接受到请求后会对该请求进行分析和处理.3.服务器处理完成后,返回对应的数据到用户浏览器.4.浏览器接受把服务器返回的数据,然后进行分析处理.渲染等操作. var http=require(‘http’);//通过http模块下的createserver创建并返回一个web服务器对象.var server=http.createServer(); //监听端口.端口:网络数据交互如QQ等数据的传输和发送都需要通过网卡,划分好对应的’分机’才能对应监听//一个应用程序可以监听多个端口数据,一个端口数据只能被一个应用监听.//server.listen(port,[hostname],[backlog],[callback])//port:监听端口.// hostname:主机名(Ip/域名).// backlog:连接等待队列的最大长度.(允许多少客户端等待)// callback:调用listen方法并成功开启监听后,//会触发一个listning事件,callback将作为该事件的执行函数.//端口号1-1024 给系统使用,server.on(‘error’,function(err){ //服务开启失败时触发 console.log(err);}) server.on(‘listening’,function(){ //调用listen方法时触发 console.log(‘listen’); })server.on(‘request’,function(req,res){ //有客户端发送请求到该主机和端口的请求的时候触发 console.log(‘有请求了’); //req:存储跟客户端发送请求的相关信息 // console.log(req); //res:服务端数据处理,向客户端发送指定的数据 res.write(‘hello’); //(chuank,encoding):发送一个数据块到响应正文中,后面是编码方式. res.end(); //(chuank,encoding):当所有的正文和头信息发送完成以后会调用该方法告诉 // 服务器数据已经全部发送完成,这个方法在每次完成信息发送以后必须调用,并且是最后调用.})res.writeHead(200,’dddd’,{ //浏览器接受到的永远都是字符串,会根据header里的类型进行设置. ‘content-type’:’text/html’, }) ;server.listen(8089,’localhost’); //浏览器输入 http://localhost:8089/ request方法就会有响应. //////////////////////////////////////// var http=require(‘http’); var url=require(‘url’);var server=http.createServer();(var fs=require(‘fs’);)server.on(‘request’,function(req,res){ var urlStr=url.parse(req.url); (var htmlDir=_dirname+’/html’;) console.log(urlStr);//将url解析成一个json对象进行查看. switch (urlStr.pathname){ case ‘/‘: ( sendData(htmlDir+’index.html’,req,res)) res.writeHead(200,{ //可以使用fs模块实现分离 ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘shouye’); break; case ‘/user’: res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘geren’); break; default: res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘beichidiao’); break; } console.log(req.url);//访问路径; ?后面的部分query string 查询字符串}) ;function sendData(file,req,res){fs.readFile(file,function(err,data){if(err){ res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘shouye’);}else{ res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘data’);}})}server.listen(8080,’localhost’); log:Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: ‘?=1’, query: ‘=1’, pathname: ‘/a’, path: ‘/a?=1’, href: ‘/a?=1’ }/a?=1 //////////////////////////////////////// urlStr里有query的值即是提交的表单Query.String: 序列化一个对象到一个query string 可以选择是否覆盖默认的分分割符(‘&amp;’)和分配符(‘=’).也可以自定义 eg:username=ab&amp;password=123 Query.parse:反序列化]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-5]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-5%2F</url>
    <content type="text"><![CDATA[本章开始学习前端项目自动化包括项目构建,自动合并等话不多说 继续开始fs模块介绍http://www.jianshu.com/p/5683c8a93511PS:{}和[]有啥区别?答案是{}里面是对象,[]则是数组 ///////////////////////////// 初始化文件项目 var projectData={ ‘name’:’miaov’, ‘fileData’:[ { ‘name’:’css’, ‘type’:’dir’ }, { ‘name’:’js’, ‘type’:’dir’ }, { ‘name’:’images’, ‘type’:’dir’ }, { ‘name’:’index.html’, ‘type’:’file’, ‘content’:’\n\t\n\t\ttitle\n\t\n\t\n\t\thello\n\t\n‘, } ] }; if(projectData.name){ fs.mkdirSync(projectData.name); var fileData=projectData.fileData; if(fileData &amp;&amp; fileData.forEach){ fileData.forEach(function(f){ f.path= projectData.name+’/‘+ f.name; f.content= f.content || ‘’; switch (f.type) { case ‘dir’: fs.mkdirSync(f.path); break; case ‘file’: fs.writeFileSync(f.path, f.content); break; } }) } } /////////////////////////////]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-4]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-4%2F</url>
    <content type="text"><![CDATA[生活不易,且行且珍惜.忙活了三天,电脑没碰,生活上的事情焦头烂额,继续吧.上次的学习主要是fs文件模块的使用,包括fs.write,fs.open,fs.read等.日常错误就是对其读写操作属性的配置.下面继续开始下一章. fs.readFile(filename,[options],callback)//异步读取一个文件的全部内容 fs.readFileSync(filename,[options])//同步 fs.unlink(filename,callback)//异步删除一个文件 fs.unlinkSync(path)//同步 fs.rename(‘oldname’,’newname’,callback)//重命名 fs.stat(path.callback)//读取文件信息(属性) { ‘0’: null, ‘1’: Stats { dev: 826654, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 60517119993054080, size: 17, blocks: undefined, atime: 2017-05-27T08:29:26.420Z, mtime: 2017-05-27T08:45:50.850Z, ctime: 2017-05-27T08:45:50.850Z, birthtime: 2017-05-27T07:51:00.935Z } } fs.watch(filename,[options],[listener])//不稳定,观察指定路径的改版 回调函数里的参数(event,filename)监听内容及命名的变化 (change,rename)event 为rename表示指定的文件或目录中有重命名、删除或移动操作或change表示有修改，filename表示发生变化的文件路径///////////////////////////// 下面是操作文件夹的一些内容fs.mkdir(path,[mode],callback) //创建文件夹fs.mkdir(‘./1’,function(){ console.log(arguments);//0:null})fs.mkdirSync(path,[mode])//同步版本 fs.readdir(path,callback)//读取文件夹fs.readdir(‘../learnnode’,function(err,fileList){ fileList.forEach(function(f){ fs.stat(f,function(err,info){ switch (info.mode){ case 16822: console.log(‘文件夹’+f); break; case 33206: console.log(‘文件’+f); break; default: console.log(f); break; } }) })}) readdir(‘../learnnode’,function(err,fileList){ fileList.forEach(function(f){ fs.stat(f,function(){ console.log(arguments); }) })})输出:{ ‘0’: null, ‘1’: Stats { dev: 826654, mode: 16822, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 3940649674220553, size: 0, blocks: undefined, atime: 2017-05-31T02:35:17.146Z, mtime: 2017-05-31T02:35:17.146Z, ctime: 2017-05-31T02:35:17.146Z, birthtime: 2017-05-31T02:35:17.146Z } }{ ‘0’: null, ‘1’: Stats { dev: 826654, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 14355223812513196, size: 6, blocks: undefined, atime: 2017-05-27T07:16:26.216Z, mtime: 2017-05-27T07:16:30.209Z, ctime: 2017-05-27T07:16:30.209Z, birthtime: 2017-05-27T06:24:41.427Z } } 注意!mode 33206代表文件,16822代表文件夹fs.readdirSync(path)//同步版本 fs.rmdir(path,callback)//删除文件夹 fs.rmdir(path)//同步版本 /////////////////////////////]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-3]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[花了一上午，在领导的指示下做了一个手机端的界面http://zhaopin.yanhuatong.com/挺丑，也就只能这样了，哈哈下午打卡，话不多说，开始吧上次学了点Buffer的指示,其实主要还是字符的拼接切割,但是又涉及到IO的操作.重点:Buffer会占用内存,写入后不会轻易更改.类方法,静态方法什么是静态方法?我也没理解透,查阅了一些资料↓静态方法也叫类方法:类方法属于类，使用时不需要实例化一个对象，直接使用类名称就可以使用。(在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。)成员方法也叫对象方法:对象方法属于某个对象实例，必须先有一个对象，才可以使用(实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。) ///////////////////////////// console.log(Buffer.isEncoding(‘utf-8’))//true console.log(Buffer.byteLength(‘utf-8’))//5 console.log(Buffer.byteLength(‘妙味’)) //6var str=’miaov’;var str2=’妙味’;var list=[new Buffer(str),new Buffer(str2)];console.log(list);//[ , ] var bf=Buffer.concat(list);console.log(bf);//var str3= bf.toString();console.log(str3);//miaov妙味//如果在输出的时候使用字符串拼接(‘xxxx’+str)会自动转化为字符串而不需要toString ///////////////////////////// File System -文件系统模块 使用方法 :require(‘fs’) fs.open(path,flags,[mode],callback);(异步,不耽误后续动作执行)path:要打开文件的路径;flags:打开文件的方式,常用的:读/写;mode:设置文件的模式:读/写/执行 4/2/1;callback:回调 err:文件打开失败的错误保存在err里面,如果成功err为Null. fd:被打开文件的标识. fs.opnSync(path,flags,[mode]);(同步,无回调函数) ///////////////////////////// fs.read(fd,buffer,offset,length,position,callback);//从指定文档标识符fd读取文件数据.fd:通过open方法成功打开一个文件返回的编号.buffer:buffer对象offset:偏移量,新的内容添加到buffer中的起始位置length:添加到buffer中内容的长度position:读取的文件中的起始位置callback:回调函数:参数有err newbuflength(长度) newbf(更改后的buffer) var bf1=new Buffer(10); console.log(bf1); fs.read(fd,bf1,0,4,null,function(err){ console.log(bf1);//// ///////////////////////////// fs.write(fd,buffer,offset,length,position,callback);fd:打开的文件buffer:要写入的数据offset:buffer对象中要 写入的数据的起始位置length:要写入的Buffer数据的长度postition:fd中起始位置callback:回调offset和position的区别是什么?offset是指new Buffer(‘123’);里的偏移量position是指fd文件被修改的起始位置 var fs=require(‘fs’); fs.open(‘1.text’,’r’,function (err,fd){ if(err){ console.log(err); } else { /*var bf1=new Buffer(10); console.log(bf1); fs.read(fd,bf1,0,4,null,function(err){ console.log(bf1); }) */ var bf=new Buffer(&apos;123&apos;); fs.write(fd,bf,0,3,0,function(){ console.log(arguments); }) } })//会报错,那是为什么呢?报错如下{ ‘0’: { Error: EPERM: operation not permitted, write at Error (native) errno: -4048, code: ‘EPERM’, syscall: ‘write’ }, ‘1’: 0, ‘2’: }注意:我们回头看起,Buffer有读写操作,当我们以只读的时候打开就无法进行写的操作 所以上面的应该改为:fs.open(‘1.text’,’r+’,function (err,fd){ fs.write(fd,’1234数据’,[encoding编码方式],callback);直接添加字符串 fs.close(fd,callback);关闭打开文件 ,无法进行后续操作. ///////////////////////////// fs.writeFile(filename,data,[options],callback)异步的将数据写入一个文件,如果文件不存在则新建,如果文件原来存在,则会被替换.data:可以是一个string,也可以是一个原生buffer.var fs=require(‘fs’);var filename=’2.txt’; fs.writeFile(filename,’hello’,function(){ console.log(arguments); }); fs.appendFile(filename,data,[options],callback)异步的将数据添加到一个文件的尾部,如果文件不存在,会创建一个新的文件,data同上.fs.appendFile(filename,’leo’,function(){})fs.appendSync(filename,data,options) 同步模式无返回值!!!fs.exists(filename,function(err){})//检测文件是否存在,true/false同步模式:var fs=require(‘fs’);var filename=’2.txt’; if(!fs.existsSync(filename)){ fs.writeFileSync(filename,’miaov’); console.log(‘xinzengchenggong’) }else{ fs.appendFileSync(filename,’-leo’); console.log(‘zhuijiachenggong’) } 为什么在检测的时候要用同步? 因为同步模式直接返回true,或者false,如果要用异步模式则需要调用callback.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-2]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[小张来打卡了,这是第二天了,忙活了一上午的数据库,总算成功的导入了.现在可以沉下心来接着看了昨天学习了一些基础的知识,主要还是require和exports的机制.今天努努力开始继续学习吧.ready go! 有点尴尬么 哈哈~http://oqfuveidu.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170526132504.jpg ///////////////////////////////console.log(_filename);返回当前模块文件的解析后的绝对路径,该属性其实并非全局的,而是模块作用域下的.//console.log(_dirname);返回当前模块文化部所以在目录解析后的绝对路径,该属性也不是全局的,而是模块作用域下的.效果如下:d:\learnnode\6.jsd:\learnnode ///////////////////////////// global:process对象process对象是一个全局对象,可以在任何地方都能访问到,通过这个对象提供的属性和方法, 使我们可以对当前运行的程序的进程进行访问和控制.process.argv:一个包含命令行参数的数组,第一个元素是node,第二个元素是.js文件名称.接下来的元素一次是命令行传入的参数. console.log(process.pid);可以进入资源管理器查看PID:任务进程编号 process.stdin,stdout :标准输入输出流(IO),提供操作输入数据和输出数据的方法 process.stdin.resume();//默认情况下,输入流是关闭的,要监听处理输入流数据,首先要开启输入流.process.stdin.on(‘data’,function(chunk) { console.log(‘yonghushuru’+chunk);});//用于监听用户输入数据 ///////////////////////////// Buffer类:一个用于 更好操作二进制数据的类(全局类) var bf=new Buffer(5);//size[num]创建一个Buffer对象,并未这个对象分配一个大小,当分配空间大小后,其长度固定,无法更改.console.log(bf);//var bf=new Buffer([1,2,3]);console.log(bf);//var bf=new Buffer(‘miaowei’,’utf-8’);//把字符串转成二进制数据,默认utf8console.log(bf);// for(var i=0;i&lt;bf.length;i++){ //bf.length指字节长度,而不是字符串长度.而在utf8编码中一个汉字占3个字节,一个字母或者数字占一个字节. console.log(String.fromCharCode(bf[i]));}//反向输出字符 buf.write():从指定的字符串当中以指定的编码写入指定长度字符.var str=”miaovvvvvv”;var bf=new Buffer(5);bf.write(str) ;console.log(bf);//bf.write(str,1,3) ; 1:偏移量(从对象的第几位开始写入,从0开始),3:指长度.console.log(bf);// var bf=new Buffer(‘miaov’);console.log(bf.toString(‘utf-8’,1,3));//ia var bf2=new Buffer(‘妙味’);console.log(bf2.toString(‘utf-8’,1));//��味 console.log(bf2.toJSON());//{ type: ‘Buffer’, data: [ 229, 166, 153, 229, 145, 179 ] }调用字符串序列号这个实例 slice(2,4);引用相同的内存地址,然后进行切割成新的字节数组buffer.bf.copy(bf4);输出bf4的Buffer值 今天完结,明天继续.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-1]]></title>
    <url>%2F2017%2F05%2F25%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[作为一个刚刚入行的小白,在学习vue.js的这种进阶的知识后发现自己还欠了很多的基础内容.在思考了很久之后我决定补一下这些知识,一步一个坎,总要踩过去.那么又面临一个问题.node.js和html5 一个偏后端一个偏前端该选择哪个呢?我很纠结在思考了一个上午后我觉得我还是需要先学node.js.为什么要学它.我的理由很简单:node.js是一门可以处理后端的技术,这样我就不用学习.net c#一类的了.哈哈…原文地址:https://www.zhihu.com/question/33578075如果有人不懂为什么要学习node.js可以看下上面的链接.视频的学习链接请百度网易云课堂不是打广告计划一个月的时间学习它.那么开始吧~Js组成: 操作浏览器 Ecmascript+BOM+DOM node.js: 操作系统网络等 Ecmascript os file net database相同点:在ECMAScript部分node和js其实是一样的,比如数据类型的定义,语法结构,内置对象等等差异性:顶层对象 js:window node:没有window概念,有global全局对象node:var a=100;console.log(global.a)//undefined//模块化:一个文件就是一个模块,每一个模块都有自己的作用域.//我们使用var来声明一个定义,他并不是全局的,而是属于当前模块下. global.a=200;console.log(a);//100console.log(global.a);//200 在一个模块下定义的变量,其作用域只是当前模块,外部无法调用. 如果想一个模块能够访问另外一个模块中定义的变量,可以: 1.把变量作为global对象的一个属性(不推荐). 2.使用模块对象module:保存提供和当前模块有关的一些信息. console.log(module); Module { id: ‘.’, exports: {}, parent: null, filename: ‘d:\learnnode\4.js’, loaded: false, children: –&gt;加载的模块 [ Module { id: ‘d:\learnnode\5.js’, exports: {}, parent: [Circular], filename: ‘d:\learnnode\5.js’, loaded: true, children: [], paths: [Object] } ], paths: [ ‘d:\learnnode\node_modules’, ‘d:\node_modules’ ] } //在这个module对象,有一个子对象:exports对象,我们可以通过这个对象把//一个模块中的局部变量对象进行提供访问.module.xeports.a=a;var m5= require(‘./5’);//这个方法的返回值,其实就是被加载模块中的module.exports 在模块作用域,还有一个内置的模块对象:exports,他其实就是module.exports. 注意:module.exports=[1,2,3];//expors和module.exports的指向关系会断开,导致exports的输出错误. 在已有的属性进行添加,而不是重写. //_filename:当前文件被解析过后的绝对路径.属于当前模块下的.//模块加载系统:require(‘模块’); eg: require(‘./2.js’); //模块加载机制: 路径 绝对路径:require(‘b:/x/x/2.js’); 相对路径:require(‘./2.js’);//未加./会加载node的核心模块,或者是node_modules require(&apos;./2&apos;)// 1.首先按照加载的模块的文件名称进行查找 2.如果没有找到,则会在模块文件名称后面加上.js的后缀,进行查找. 3.如果还么有找到,则会在文件名称后面加上.json的后缀,进行查找. 4.如果还没有找到,则会在文件名称后面加上.node的后缀,进行查找. 5.还为找到,抛出错误.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F05%2F24%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我在Github上第一次搭建博客.遇到了很多的困难也得到了很多的帮助,如果你也想搭建一个这样的博客,不妨参考下这个帮助:https://fzy-line.github.io/ 如果你遇到了在分类和标签上出现无法加载的情况,请不要着急,在你生成的页面后进入/sourse/tags里加入layout: “tags”. 下面是网站的发布流程:新建博客 $ hexo new “我的第一篇博客”到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。 编辑博客 Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下： title: 我的第一篇博客date: 2016-12-02 23:44:20 tags: #文章标签 可以省略tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做： tags: [Linux,Http,网络]我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如： categories: Linux 发布博客 $ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 $ hexo generate #生成静态页面至public目录写好之后可以现在本地预览，确定无误之后再部署到Github上。 $ hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） $ hexo deploy #将.deploy目录部署到GitHub需要说明的是： 我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。 hexo命令简写形式 hexo n “我的博客” == hexo new “我的博客”hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
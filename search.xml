<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于node.js的学习-3]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[花了一上午，在领导的指示下做了一个手机端的界面http://zhaopin.yanhuatong.com/挺丑，也就只能这样了，哈哈下午打卡，话不多说，开始吧上次学了点Buffer的指示,其实主要还是字符的拼接切割,但是又涉及到IO的操作.重点:Buffer会占用内存,写入后不会轻易更改.类方法,静态方法什么是静态方法?我也没理解透,查阅了一些资料↓静态方法也叫类方法:类方法属于类，使用时不需要实例化一个对象，直接使用类名称就可以使用。(在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。)成员方法也叫对象方法:对象方法属于某个对象实例，必须先有一个对象，才可以使用(实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。) ///////////////////////////// console.log(Buffer.isEncoding(‘utf-8’))//true console.log(Buffer.byteLength(‘utf-8’))//5 console.log(Buffer.byteLength(‘妙味’)) //6var str=’miaov’;var str2=’妙味’;var list=[new Buffer(str),new Buffer(str2)];console.log(list);//[ , ] var bf=Buffer.concat(list);console.log(bf);//var str3= bf.toString();console.log(str3);//miaov妙味//如果在输出的时候使用字符串拼接(‘xxxx’+str)会自动转化为字符串而不需要toString ///////////////////////////// File System -文件系统模块 使用方法 :require(‘fs’) fs.open(path,flags,[mode],callback);(异步,不耽误后续动作执行)path:要打开文件的路径;flags:打开文件的方式,常用的:读/写;mode:设置文件的模式:读/写/执行 4/2/1;callback:回调 err:文件打开失败的错误保存在err里面,如果成功err为Null. fd:被打开文件的标识. fs.opnSync(path,flags,[mode]);(同步,无回调函数) ///////////////////////////// fs.read(fd,buffer,offset,length,position,callback);//从指定文档标识符fd读取文件数据.fd:通过open方法成功打开一个文件返回的编号.buffer:buffer对象offset:偏移量,新的内容添加到buffer中的起始位置length:添加到buffer中内容的长度position:读取的文件中的起始位置callback:回调函数:参数有err newbuflength(长度) newbf(更改后的buffer) var bf1=new Buffer(10); console.log(bf1); fs.read(fd,bf1,0,4,null,function(err){ console.log(bf1);//// ///////////////////////////// fs.write(fd,buffer,offset,length,position,callback);fd:打开的文件buffer:要写入的数据offset:buffer对象中要 写入的数据的起始位置length:要写入的Buffer数据的长度postition:fd中起始位置callback:回调offset和position的区别是什么?offset是指new Buffer(‘123’);里的偏移量position是指fd文件被修改的起始位置 var fs=require(‘fs’); fs.open(‘1.text’,’r’,function (err,fd){ if(err){ console.log(err); } else { /*var bf1=new Buffer(10); console.log(bf1); fs.read(fd,bf1,0,4,null,function(err){ console.log(bf1); }) */ var bf=new Buffer(&apos;123&apos;); fs.write(fd,bf,0,3,0,function(){ console.log(arguments); }) } })//会报错,那是为什么呢?报错如下{ ‘0’: { Error: EPERM: operation not permitted, write at Error (native) errno: -4048, code: ‘EPERM’, syscall: ‘write’ }, ‘1’: 0, ‘2’: }注意:我们回头看起,Buffer有读写操作,当我们以只读的时候打开就无法进行写的操作 所以上面的应该改为:fs.open(‘1.text’,’r+’,function (err,fd){ fs.write(fd,’1234数据’,[encoding编码方式],callback);直接添加字符串 fs.close(fd,callback);关闭打开文件 ,无法进行后续操作. ///////////////////////////// fs.writeFile(filename,data,[options],callback)异步的将数据写入一个文件,如果文件不存在则新建,如果文件原来存在,则会被替换.data:可以是一个string,也可以是一个原生buffer.var fs=require(‘fs’);var filename=’2.txt’; fs.writeFile(filename,’hello’,function(){ console.log(arguments); }); fs.appendFile(filename,data,[options],callback)异步的将数据添加到一个文件的尾部,如果文件不存在,会创建一个新的文件,data同上.fs.appendFile(filename,’leo’,function(){})fs.appendSync(filename,data,options) 同步模式无返回值!!!fs.exists(filename,function(err){})//检测文件是否存在,true/false同步模式:var fs=require(‘fs’);var filename=’2.txt’; if(!fs.existsSync(filename)){ fs.writeFileSync(filename,’miaov’); console.log(‘xinzengchenggong’) }else{ fs.appendFileSync(filename,’-leo’); console.log(‘zhuijiachenggong’) } 为什么在检测的时候要用同步? 因为同步模式直接返回true,或者false,如果要用异步模式则需要调用callback.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-2]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[小张来打卡了,这是第二天了,忙活了一上午的数据库,总算成功的导入了.现在可以沉下心来接着看了昨天学习了一些基础的知识,主要还是require和exports的机制.今天努努力开始继续学习吧.ready go! 有点尴尬么 哈哈~http://oqfuveidu.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170526132504.jpg ///////////////////////////////console.log(_filename);返回当前模块文件的解析后的绝对路径,该属性其实并非全局的,而是模块作用域下的.//console.log(_dirname);返回当前模块文化部所以在目录解析后的绝对路径,该属性也不是全局的,而是模块作用域下的.效果如下:d:\learnnode\6.jsd:\learnnode ///////////////////////////// global:process对象process对象是一个全局对象,可以在任何地方都能访问到,通过这个对象提供的属性和方法, 使我们可以对当前运行的程序的进程进行访问和控制.process.argv:一个包含命令行参数的数组,第一个元素是node,第二个元素是.js文件名称.接下来的元素一次是命令行传入的参数. console.log(process.pid);可以进入资源管理器查看PID:任务进程编号 process.stdin,stdout :标准输入输出流(IO),提供操作输入数据和输出数据的方法 process.stdin.resume();//默认情况下,输入流是关闭的,要监听处理输入流数据,首先要开启输入流.process.stdin.on(‘data’,function(chunk) { console.log(‘yonghushuru’+chunk);});//用于监听用户输入数据 ///////////////////////////// Buffer类:一个用于 更好操作二进制数据的类(全局类) var bf=new Buffer(5);//size[num]创建一个Buffer对象,并未这个对象分配一个大小,当分配空间大小后,其长度固定,无法更改.console.log(bf);//var bf=new Buffer([1,2,3]);console.log(bf);//var bf=new Buffer(‘miaowei’,’utf-8’);//把字符串转成二进制数据,默认utf8console.log(bf);// for(var i=0;i&lt;bf.length;i++){ //bf.length指字节长度,而不是字符串长度.而在utf8编码中一个汉字占3个字节,一个字母或者数字占一个字节. console.log(String.fromCharCode(bf[i]));}//反向输出字符 buf.write():从指定的字符串当中以指定的编码写入指定长度字符.var str=”miaovvvvvv”;var bf=new Buffer(5);bf.write(str) ;console.log(bf);//bf.write(str,1,3) ; 1:偏移量(从对象的第几位开始写入,从0开始),3:指长度.console.log(bf);// var bf=new Buffer(‘miaov’);console.log(bf.toString(‘utf-8’,1,3));//ia var bf2=new Buffer(‘妙味’);console.log(bf2.toString(‘utf-8’,1));//��味 console.log(bf2.toJSON());//{ type: ‘Buffer’, data: [ 229, 166, 153, 229, 145, 179 ] }调用字符串序列号这个实例 slice(2,4);引用相同的内存地址,然后进行切割成新的字节数组buffer.bf.copy(bf4);输出bf4的Buffer值 今天完结,明天继续.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-1]]></title>
    <url>%2F2017%2F05%2F25%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[作为一个刚刚入行的小白,在学习vue.js的这种进阶的知识后发现自己还欠了很多的基础内容.在思考了很久之后我决定补一下这些知识,一步一个坎,总要踩过去.那么又面临一个问题.node.js和html5 一个偏后端一个偏前端该选择哪个呢?我很纠结在思考了一个上午后我觉得我还是需要先学node.js.为什么要学它.我的理由很简单:node.js是一门可以处理后端的技术,这样我就不用学习.net c#一类的了.哈哈…原文地址:https://www.zhihu.com/question/33578075如果有人不懂为什么要学习node.js可以看下上面的链接.视频的学习链接请百度网易云课堂不是打广告计划一个月的时间学习它.那么开始吧~Js组成: 操作浏览器 Ecmascript+BOM+DOM node.js: 操作系统网络等 Ecmascript os file net database相同点:在ECMAScript部分node和js其实是一样的,比如数据类型的定义,语法结构,内置对象等等差异性:顶层对象 js:window node:没有window概念,有global全局对象node:var a=100;console.log(global.a)//undefined//模块化:一个文件就是一个模块,每一个模块都有自己的作用域.//我们使用var来声明一个定义,他并不是全局的,而是属于当前模块下. global.a=200;console.log(a);//100console.log(global.a);//200 在一个模块下定义的变量,其作用域只是当前模块,外部无法调用. 如果想一个模块能够访问另外一个模块中定义的变量,可以: 1.把变量作为global对象的一个属性(不推荐). 2.使用模块对象module:保存提供和当前模块有关的一些信息. console.log(module); Module { id: ‘.’, exports: {}, parent: null, filename: ‘d:\learnnode\4.js’, loaded: false, children: –&gt;加载的模块 [ Module { id: ‘d:\learnnode\5.js’, exports: {}, parent: [Circular], filename: ‘d:\learnnode\5.js’, loaded: true, children: [], paths: [Object] } ], paths: [ ‘d:\learnnode\node_modules’, ‘d:\node_modules’ ] } //在这个module对象,有一个子对象:exports对象,我们可以通过这个对象把//一个模块中的局部变量对象进行提供访问.module.xeports.a=a;var m5= require(‘./5’);//这个方法的返回值,其实就是被加载模块中的module.exports 在模块作用域,还有一个内置的模块对象:exports,他其实就是module.exports. 注意:module.exports=[1,2,3];//expors和module.exports的指向关系会断开,导致exports的输出错误. 在已有的属性进行添加,而不是重写. //_filename:当前文件被解析过后的绝对路径.属于当前模块下的.//模块加载系统:require(‘模块’); eg: require(‘./2.js’); //模块加载机制: 路径 绝对路径:require(‘b:/x/x/2.js’); 相对路径:require(‘./2.js’);//未加./会加载node的核心模块,或者是node_modules require(&apos;./2&apos;)// 1.首先按照加载的模块的文件名称进行查找 2.如果没有找到,则会在模块文件名称后面加上.js的后缀,进行查找. 3.如果还么有找到,则会在文件名称后面加上.json的后缀,进行查找. 4.如果还没有找到,则会在文件名称后面加上.node的后缀,进行查找. 5.还为找到,抛出错误.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F05%2F24%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我在Github上第一次搭建博客.遇到了很多的困难也得到了很多的帮助,如果你也想搭建一个这样的博客,不妨参考下这个帮助:https://fzy-line.github.io/ 如果你遇到了在分类和标签上出现无法加载的情况,请不要着急,在你生成的页面后进入/sourse/tags里加入layout: “tags”. 下面是网站的发布流程:新建博客 $ hexo new “我的第一篇博客”到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。 编辑博客 Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下： title: 我的第一篇博客date: 2016-12-02 23:44:20 tags: #文章标签 可以省略tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做： tags: [Linux,Http,网络]我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如： categories: Linux 发布博客 $ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 $ hexo generate #生成静态页面至public目录写好之后可以现在本地预览，确定无误之后再部署到Github上。 $ hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） $ hexo deploy #将.deploy目录部署到GitHub需要说明的是： 我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。 hexo命令简写形式 hexo n “我的博客” == hexo new “我的博客”hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
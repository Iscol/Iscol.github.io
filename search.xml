<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[仿头条表格类型设计]]></title>
    <url>%2F2017%2F06%2F12%2F%E4%BB%BF%E5%A4%B4%E6%9D%A1%E8%A1%A8%E6%A0%BC%E7%B1%BB%E5%9E%8B-C%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[捯饬了一天的菜单悬浮效果代码如下&lt;!DOCTYPE html&gt; body, div, h1, h2, h3, h4, h5, h6, ul, li, img { margin: 0; padding: 0; font-size:30px; } .trr td { width:800px; } #MyTable_tableLayout{ overflow:hidden; height:100%; width:100%; } #MyTable_tableFix{ height: 107px; width: 142px; overflow: hidden; position: relative; z-index: 50; top: 0px; left: 0px; background-color: silver; } #MyTable_tableFixClone{ width: 960px; font-family: 微软雅黑; color: rgb(0, 0, 0); font-size: medium; border-color: black; margin: 0px; } th{ text-align: center; width: 80px; border: 1px solid silver; border-collapse: collapse; padding: 3px; font-family: 微软雅黑; color: rgb(0, 0, 0); font-size: medium; line-height: 1.8; display: table-cell; vertical-align: inherit; font-weight: bold; } td{ border: 1px solid silver; border-collapse: collapse; padding: 3px; font-family: 微软雅黑; color: rgb(0, 0, 0); font-size: medium; line-height: 1.8; word-break: break-all; } #MyTable_tableHead{ height: 107px; overflow: hidden; width: 483px; position: relative; z-index: 45; top: -107px; left: 0px; background-color: silver; } #MyTable_tableHeadClone{ width: 960px; font-family: 微软雅黑; color: rgb(0, 0, 0); font-size: medium; border-color: black; margin: 0px; } #MyTable_tableColumn{ width: 142px; overflow: hidden; height: 283px; position: relative; z-index: 40; top: -214px; left: 0px; background-color: silver; } #MyTable_tableColumnClone{ width: 960px; font-family: 微软雅黑; color: rgb(0, 0, 0); font-size: medium; border-color: black; margin: 0px; } #MyTable_tableData{ overflow: scroll; width: 500px; height: 300px; position: relative; z-index: 35; top: -497px; left: 0px; } #MyTable{ width: 960px; font-family: 微软雅黑; color: rgb(0, 0, 0); font-size: medium; border-color: black; margin: 0px; } $(function () { var str = ‘姓名姓名姓名班级语文数学英语政治历史地理物理化学生物总分‘; str += ““; for (var i = 0; i &lt; 100; i++) { str += ‘‘ + i + ‘‘ + i + ‘364&nbsp;64&nbsp;64&nbsp;104&nbsp;150&nbsp;93&nbsp;32&nbsp;82&nbsp;26&nbsp;44&nbsp;83&nbsp;678&nbsp;‘; } str += ““; $(“#MyTable_tableFixClone”).html(str); $(“#MyTable_tableHeadClone”).html(str); $(“#MyTable_tableColumnClone”).html(str); $(“#MyTable”).html(str); }) $(document).ready(function () { var x = $(window).width(); var y = $(window).height(); $(“#MyTable_tableLayout”).height(y).width(x); FixTable(“MyTable”, 1, x, y); }); function FixTable(TableID, FixColumnNumber, width, height) { /// /// 锁定表头和列 /// sorex.cnblogs.com /// /// /// 要锁定的Table的ID /// /// /// 要锁定列的个数 /// /// /// 显示的宽度 /// /// /// 显示的高度 /// if ($(“#” + TableID + “_tableLayout”).length != 0) { $(“#” + TableID + “_tableLayout”).before($(“#” + TableID)); $(“#” + TableID + “_tableLayout”).empty(); } else { $(“#” + TableID).after(““); } $(‘‘ + ‘‘ + ‘‘ + ‘‘).appendTo(“#” + TableID + “_tableLayout”); var oldtable = $(“#” + TableID); var tableFixClone = oldtable.clone(true); tableFixClone.attr(“id”, TableID + “_tableFixClone”); $(“#” + TableID + “_tableFix”).append(tableFixClone); var tableHeadClone = oldtable.clone(true); tableHeadClone.attr(“id”, TableID + “_tableHeadClone”); $(“#” + TableID + “_tableHead”).append(tableHeadClone); var tableColumnClone = oldtable.clone(true); tableColumnClone.attr(“id”, TableID + “_tableColumnClone”); $(“#” + TableID + “_tableColumn”).append(tableColumnClone); $(“#” + TableID + “_tableData”).append(oldtable); $(“#” + TableID + “_tableLayout table”).each(function () { $(this).css(“margin”, “0”); }); var HeadHeight = $(“#” + TableID + “_tableHead thead”).height(); HeadHeight += 2; $(“#” + TableID + “_tableHead”).css(“height”, HeadHeight); $(“#” + TableID + “_tableFix”).css(“height”, HeadHeight); var ColumnsWidth = 0; var ColumnsNumber = 0; $(“#” + TableID + “_tableColumn tr:last td:lt(“ + FixColumnNumber + “)”).each(function () { ColumnsWidth += $(this).outerWidth(true); ColumnsNumber++; }); ColumnsWidth += 2; if ($.browser.msie) { switch ($.browser.version) { case “7.0”: if (ColumnsNumber &gt;= 3) ColumnsWidth–; break; case “8.0”: if (ColumnsNumber &gt;= 2) ColumnsWidth–; break; } } $(“#” + TableID + “_tableColumn”).css(“width”, ColumnsWidth); $(“#” + TableID + “_tableFix”).css(“width”, ColumnsWidth); $(“#” + TableID + “_tableData”).scroll(function () { $(“#” + TableID + “_tableHead”).scrollLeft($(“#” + TableID + “_tableData”).scrollLeft()); $(“#” + TableID + “_tableColumn”).scrollTop($(“#” + TableID + “_tableData”).scrollTop()); }); $(“#” + TableID + “_tableFix”).css({ “overflow”: “hidden”, “position”: “relative”, “z-index”: “50”, “background-color”: “Silver” }); $(“#” + TableID + “_tableHead”).css({ “overflow”: “hidden”, “width”: width //- 17 //滚动轴 , “position”: “relative”, “z-index”: “45”, “background-color”: “Silver” }); $(“#” + TableID + “_tableColumn”).css({ “overflow”: “hidden”, “height”: height //- 17 //滚动轴 , “position”: “relative”, “z-index”: “40”, “background-color”: “Silver” }); $(“#” + TableID + “_tableData”).css({ “overflow”: “scroll”, “width”: width, “height”: height, “position”: “relative”, “z-index”: “35” }); if ($(“#” + TableID + “_tableHead”).width() &gt; $(“#” + TableID + “_tableFix table”).width()) { $(“#” + TableID + “_tableHead”).css(“width”, $(“#” + TableID + “_tableFix table”).width()); $(“#” + TableID + “_tableData”).css(“width”, $(“#” + TableID + “_tableFix table”).width() + 17); } if ($(“#” + TableID + “_tableColumn”).height() &gt; $(“#” + TableID + “_tableColumn table”).height()) { $(“#” + TableID + “_tableColumn”).css(“height”, $(“#” + TableID + “_tableColumn table”).height()); $(“#” + TableID + “_tableData”).css(“height”, $(“#” + TableID + “_tableColumn table”).height() + 17); } $(“#” + TableID + “_tableFix”).offset($(“#” + TableID + “_tableLayout”).offset()); $(“#” + TableID + “_tableHead”).offset($(“#” + TableID + “_tableLayout”).offset()); $(“#” + TableID + “_tableColumn”).offset($(“#” + TableID + “_tableLayout”).offset()); $(“#” + TableID + “_tableData”).offset($(“#” + TableID + “_tableLayout”).offset()); } migrate.js源码/*! jQuery Migrate - v1.1.0 - 2013-01-31 https://github.com/jquery/jquery-migrate Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors; Licensed MIT*/(function( jQuery, window, undefined ) {“use strict”; var warnedAbout = {}; // List of warnings already given; public read onlyjQuery.migrateWarnings = []; // Set to true to prevent console output; migrateWarnings still maintained// jQuery.migrateMute = false; // Show a message on the console so devs know we’re activeif ( !jQuery.migrateMute &amp;&amp; window.console &amp;&amp; console.log ) { console.log(“JQMIGRATE: Logging is active”);} // Set to false to disable traces that appear with warningsif ( jQuery.migrateTrace === undefined ) { jQuery.migrateTrace = true;} // Forget any warnings we’ve already given; publicjQuery.migrateReset = function() { warnedAbout = {}; jQuery.migrateWarnings.length = 0;}; function migrateWarn( msg) { if ( !warnedAbout[ msg ] ) { warnedAbout[ msg ] = true; jQuery.migrateWarnings.push( msg ); if ( window.console &amp;&amp; console.warn &amp;&amp; !jQuery.migrateMute ) { console.warn( “JQMIGRATE: “ + msg ); if ( jQuery.migrateTrace &amp;&amp; console.trace ) { console.trace(); } } }} function migrateWarnProp( obj, prop, value, msg ) { if ( Object.defineProperty ) { // On ES5 browsers (non-oldIE), warn if the code tries to get prop; // allow property to be overwritten in case some other plugin wants it try { Object.defineProperty( obj, prop, { configurable: true, enumerable: true, get: function() { migrateWarn( msg ); return value; }, set: function( newValue ) { migrateWarn( msg ); value = newValue; } }); return; } catch( err ) { // IE8 is a dope about Object.defineProperty, can’t warn there } } // Non-ES5 (or broken) browser; just set the property jQuery._definePropertyBroken = true; obj[ prop ] = value; } if ( document.compatMode === “BackCompat” ) { // jQuery has never supported or tested Quirks Mode migrateWarn( “jQuery is not compatible with Quirks Mode” );} var attrFn = {}, oldAttr = jQuery.attr, valueAttrGet = jQuery.attrHooks.value &amp;&amp; jQuery.attrHooks.value.get || function() { return null; }, valueAttrSet = jQuery.attrHooks.value &amp;&amp; jQuery.attrHooks.value.set || function() { return undefined; }, rnoType = /^(?:input|button)$/i, rnoAttrNodeType = /^[238]$/, rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, ruseDefault = /^(?:checked|selected)$/i; // jQuery.attrFnmigrateWarnProp( jQuery, “attrFn”, attrFn, “jQuery.attrFn is deprecated” ); jQuery.attr = function( elem, name, value, pass ) { var lowerName = name.toLowerCase(), nType = elem &amp;&amp; elem.nodeType; // Since pass is used internally, we only warn and shim for new jQuery // versions where there isn&apos;t a pass arg in the formal params if ( pass &amp;&amp; oldAttr.length &lt; 4 ) { migrateWarn(&quot;jQuery.fn.attr( props, pass ) is deprecated&quot;); if ( elem &amp;&amp; !rnoAttrNodeType.test( nType ) &amp;&amp; jQuery.isFunction( jQuery.fn[ name ] ) ) { return jQuery( elem )[ name ]( value ); } } // Warn if user tries to set `type`, since it breaks on IE 6/7/8; by checking // for disconnected elements we don&apos;t warn on $( &quot;&lt;button&gt;&quot;, { type: &quot;button&quot; } ). if ( name === &quot;type&quot; &amp;&amp; value !== undefined &amp;&amp; rnoType.test( elem.nodeName ) &amp;&amp; elem.parentNode ) { migrateWarn(&quot;Can&apos;t change the &apos;type&apos; of an input or button in IE 6/7/8&quot;); } // Restore boolHook for boolean property/attribute synchronization if ( !jQuery.attrHooks[ lowerName ] &amp;&amp; rboolean.test( lowerName ) ) { jQuery.attrHooks[ lowerName ] = { get: function( elem, name ) { // Align boolean attributes with corresponding properties // Fall back to attribute presence where some booleans are not supported var attrNode, property = jQuery.prop( elem, name ); return property === true || typeof property !== &quot;boolean&quot; &amp;&amp; ( attrNode = elem.getAttributeNode(name) ) &amp;&amp; attrNode.nodeValue !== false ? name.toLowerCase() : undefined; }, set: function( elem, value, name ) { var propName; if ( value === false ) { // Remove boolean attributes when set to false jQuery.removeAttr( elem, name ); } else { // value is true since we know at this point it&apos;s type boolean and not false // Set boolean attributes to the same name and set the DOM property propName = jQuery.propFix[ name ] || name; if ( propName in elem ) { // Only set the IDL specifically if it already exists on the element elem[ propName ] = true; } elem.setAttribute( name, name.toLowerCase() ); } return name; } }; // Warn only for attributes that can remain distinct from their properties post-1.9 if ( ruseDefault.test( lowerName ) ) { migrateWarn( &quot;jQuery.fn.attr(&apos;&quot; + lowerName + &quot;&apos;) may use property instead of attribute&quot; ); } } return oldAttr.call( jQuery, elem, name, value ); }; // attrHooks: valuejQuery.attrHooks.value = { get: function( elem, name ) { var nodeName = ( elem.nodeName || “” ).toLowerCase(); if ( nodeName === “button” ) { return valueAttrGet.apply( this, arguments ); } if ( nodeName !== “input” &amp;&amp; nodeName !== “option” ) { migrateWarn(“jQuery.fn.attr(‘value’) no longer gets properties”); } return name in elem ? elem.value : null; }, set: function( elem, value ) { var nodeName = ( elem.nodeName || “” ).toLowerCase(); if ( nodeName === “button” ) { return valueAttrSet.apply( this, arguments ); } if ( nodeName !== “input” &amp;&amp; nodeName !== “option” ) { migrateWarn(“jQuery.fn.attr(‘value’, val) no longer sets properties”); } // Does not return so that setAttribute is also used elem.value = value; }}; var matched, browser, oldInit = jQuery.fn.init, oldParseJSON = jQuery.parseJSON, // Note this does NOT include the #9521 XSS fix from 1.7! rquickExpr = /^(?:[^&lt;](&lt;[\w\W]+&gt;)[^&gt;]|#([\w-]*))$/; // $(html) “looks like html” rule changejQuery.fn.init = function( selector, context, rootjQuery ) { var match; if ( selector &amp;&amp; typeof selector === &quot;string&quot; &amp;&amp; !jQuery.isPlainObject( context ) &amp;&amp; (match = rquickExpr.exec( selector )) &amp;&amp; match[1] ) { // This is an HTML string according to the &quot;old&quot; rules; is it still? if ( selector.charAt( 0 ) !== &quot;&lt;&quot; ) { migrateWarn(&quot;$(html) HTML strings must start with &apos;&lt;&apos; character&quot;); } // Now process using loose rules; let pre-1.8 play too if ( context &amp;&amp; context.context ) { // jQuery object as context; parseHTML expects a DOM object context = context.context; } if ( jQuery.parseHTML ) { return oldInit.call( this, jQuery.parseHTML( jQuery.trim(selector), context, true ), context, rootjQuery ); } } return oldInit.apply( this, arguments ); };jQuery.fn.init.prototype = jQuery.fn; // Let $.parseJSON(falsy_value) return nulljQuery.parseJSON = function( json ) { if ( !json &amp;&amp; json !== null ) { migrateWarn(“jQuery.parseJSON requires a valid JSON string”); return null; } return oldParseJSON.apply( this, arguments );}; jQuery.uaMatch = function( ua ) { ua = ua.toLowerCase(); var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) || /(webkit)[ \/]([\w.]+)/.exec( ua ) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) || /(msie) ([\w.]+)/.exec( ua ) || ua.indexOf(&quot;compatible&quot;) &lt; 0 &amp;&amp; /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) || []; return { browser: match[ 1 ] || &quot;&quot;, version: match[ 2 ] || &quot;0&quot; }; }; matched = jQuery.uaMatch( navigator.userAgent );browser = {}; if ( matched.browser ) { browser[ matched.browser ] = true; browser.version = matched.version;} // Chrome is Webkit, but Webkit is also Safari.if ( browser.chrome ) { browser.webkit = true;} else if ( browser.webkit ) { browser.safari = true;} jQuery.browser = browser; // Warn if the code tries to get jQuery.browsermigrateWarnProp( jQuery, “browser”, browser, “jQuery.browser is deprecated” ); jQuery.sub = function() { function jQuerySub( selector, context ) { return new jQuerySub.fn.init( selector, context ); } jQuery.extend( true, jQuerySub, this ); jQuerySub.superclass = this; jQuerySub.fn = jQuerySub.prototype = this(); jQuerySub.fn.constructor = jQuerySub; jQuerySub.sub = this.sub; jQuerySub.fn.init = function init( selector, context ) { if ( context &amp;&amp; context instanceof jQuery &amp;&amp; !(context instanceof jQuerySub) ) { context = jQuerySub( context ); } return jQuery.fn.init.call( this, selector, context, rootjQuerySub ); }; jQuerySub.fn.init.prototype = jQuerySub.fn; var rootjQuerySub = jQuerySub(document); migrateWarn( &quot;jQuery.sub() is deprecated&quot; ); return jQuerySub; }; var oldFnData = jQuery.fn.data; jQuery.fn.data = function( name ) { var ret, evt, elem = this[0]; // Handles 1.7 which has this behavior and 1.8 which doesn&apos;t if ( elem &amp;&amp; name === &quot;events&quot; &amp;&amp; arguments.length === 1 ) { ret = jQuery.data( elem, name ); evt = jQuery._data( elem, name ); if ( ( ret === undefined || ret === evt ) &amp;&amp; evt !== undefined ) { migrateWarn(&quot;Use of jQuery.fn.data(&apos;events&apos;) is deprecated&quot;); return evt; } } return oldFnData.apply( this, arguments ); }; var rscriptType = /\/(java|ecma)script/i, oldSelf = jQuery.fn.andSelf || jQuery.fn.addBack; jQuery.fn.andSelf = function() { migrateWarn(“jQuery.fn.andSelf() replaced by jQuery.fn.addBack()”); return oldSelf.apply( this, arguments );}; // Since jQuery.clean is used internally on older versions, we only shim if it’s missingif ( !jQuery.clean ) { jQuery.clean = function( elems, context, fragment, scripts ) { // Set context per 1.8 logic context = context || document; context = !context.nodeType &amp;&amp; context[0] || context; context = context.ownerDocument || context; migrateWarn(&quot;jQuery.clean() is deprecated&quot;); var i, elem, handleScript, jsTags, ret = []; jQuery.merge( ret, jQuery.buildFragment( elems, context ).childNodes ); // Complex logic lifted directly from jQuery 1.8 if ( fragment ) { // Special handling of each script element handleScript = function( elem ) { // Check if we consider it executable if ( !elem.type || rscriptType.test( elem.type ) ) { // Detach the script and store it in the scripts array (if provided) or the fragment // Return truthy to indicate that it has been handled return scripts ? scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) : fragment.appendChild( elem ); } }; for ( i = 0; (elem = ret[i]) != null; i++ ) { // Check if we&apos;re done after handling an executable script if ( !( jQuery.nodeName( elem, &quot;script&quot; ) &amp;&amp; handleScript( elem ) ) ) { // Append to fragment and handle embedded scripts fragment.appendChild( elem ); if ( typeof elem.getElementsByTagName !== &quot;undefined&quot; ) { // handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName(&quot;script&quot;) ), handleScript ); // Splice the scripts into ret after their former ancestor and advance our index beyond them ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) ); i += jsTags.length; } } } } return ret; }; } var eventAdd = jQuery.event.add, eventRemove = jQuery.event.remove, eventTrigger = jQuery.event.trigger, oldToggle = jQuery.fn.toggle, oldLive = jQuery.fn.live, oldDie = jQuery.fn.die, ajaxEvents = “ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess”, rajaxEvent = new RegExp( “\b(?:” + ajaxEvents + “)\b” ), rhoverHack = /(?:^|\s)hover(.\S+|)\b/, hoverHack = function( events ) { if ( typeof( events ) != “string” || jQuery.event.special.hover ) { return events; } if ( rhoverHack.test( events ) ) { migrateWarn(“‘hover’ pseudo-event is deprecated, use ‘mouseenter mouseleave’”); } return events &amp;&amp; events.replace( rhoverHack, “mouseenter$1 mouseleave$1” ); }; // Event props removed in 1.9, put them back if needed; no practical way to warn themif ( jQuery.event.props &amp;&amp; jQuery.event.props[ 0 ] !== “attrChange” ) { jQuery.event.props.unshift( “attrChange”, “attrName”, “relatedNode”, “srcElement” );} // Undocumented jQuery.event.handle was “deprecated” in jQuery 1.7if ( jQuery.event.dispatch ) { migrateWarnProp( jQuery.event, “handle”, jQuery.event.dispatch, “jQuery.event.handle is undocumented and deprecated” );} // Support for ‘hover’ pseudo-event and ajax event warningsjQuery.event.add = function( elem, types, handler, data, selector ){ if ( elem !== document &amp;&amp; rajaxEvent.test( types ) ) { migrateWarn( “AJAX events should be attached to document: “ + types ); } eventAdd.call( this, elem, hoverHack( types || “” ), handler, data, selector );};jQuery.event.remove = function( elem, types, handler, selector, mappedTypes ){ eventRemove.call( this, elem, hoverHack( types ) || “”, handler, selector, mappedTypes );}; jQuery.fn.error = function() { var args = Array.prototype.slice.call( arguments, 0); migrateWarn(“jQuery.fn.error() is deprecated”); args.splice( 0, 0, “error” ); if ( arguments.length ) { return this.bind.apply( this, args ); } // error event should not bubble to window, although it does pre-1.7 this.triggerHandler.apply( this, args ); return this;}; jQuery.fn.toggle = function( fn, fn2 ) { // Don&apos;t mess with animation or css toggles if ( !jQuery.isFunction( fn ) || !jQuery.isFunction( fn2 ) ) { return oldToggle.apply( this, arguments ); } migrateWarn(&quot;jQuery.fn.toggle(handler, handler...) is deprecated&quot;); // Save reference to arguments for access in closure var args = arguments, guid = fn.guid || jQuery.guid++, i = 0, toggler = function( event ) { // Figure out which function to execute var lastToggle = ( jQuery._data( this, &quot;lastToggle&quot; + fn.guid ) || 0 ) % i; jQuery._data( this, &quot;lastToggle&quot; + fn.guid, lastToggle + 1 ); // Make sure that clicks stop event.preventDefault(); // and execute the function return args[ lastToggle ].apply( this, arguments ) || false; }; // link all the functions, so any of them can unbind this click handler toggler.guid = guid; while ( i &lt; args.length ) { args[ i++ ].guid = guid; } return this.click( toggler ); }; jQuery.fn.live = function( types, data, fn ) { migrateWarn(“jQuery.fn.live() is deprecated”); if ( oldLive ) { return oldLive.apply( this, arguments ); } jQuery( this.context ).on( types, this.selector, data, fn ); return this;}; jQuery.fn.die = function( types, fn ) { migrateWarn(“jQuery.fn.die() is deprecated”); if ( oldDie ) { return oldDie.apply( this, arguments ); } jQuery( this.context ).off( types, this.selector || “**”, fn ); return this;}; // Turn global events into document-triggered eventsjQuery.event.trigger = function( event, data, elem, onlyHandlers ){ if ( !elem &amp; !rajaxEvent.test( event ) ) { migrateWarn( “Global events are undocumented and deprecated” ); } return eventTrigger.call( this, event, data, elem || document, onlyHandlers );};jQuery.each( ajaxEvents.split(“|”), function( _, name ) { jQuery.event.special[ name ] = { setup: function() { var elem = this; // The document needs no shimming; must be !== for oldIE if ( elem !== document ) { jQuery.event.add( document, name + &quot;.&quot; + jQuery.guid, function() { jQuery.event.trigger( name, null, elem, true ); }); jQuery._data( this, name, jQuery.guid++ ); } return false; }, teardown: function() { if ( this !== document ) { jQuery.event.remove( document, name + &quot;.&quot; + jQuery._data( this, name ) ); } return false; } }; } ); })( jQuery, window );]]></content>
      <categories>
        <category>jQuery导航菜单特效</category>
      </categories>
      <tags>
        <tag>excel悬浮</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex-box-1]]></title>
    <url>%2F2017%2F06%2F12%2Fflex-box-1%2F</url>
    <content type="text"></content>
      <categories>
        <category>flex-box</category>
      </categories>
      <tags>
        <tag>flex-box基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node-js的学习-博客5]]></title>
    <url>%2F2017%2F06%2F12%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A25%2F</url>
    <content type="text"><![CDATA[没啥事千万不要把代码往上放,敏感到直接需要转义,这样真的很费劲一翻开上次的内容简直乱糟糟 -~尴尬]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node-js的学习-博客4]]></title>
    <url>%2F2017%2F06%2F08%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A24%2F</url>
    <content type="text"><![CDATA[不知道是不是我太菜了,还是github太敏感了,网站崩了一上午了,找了许多原因查看了很多的网站,终于找到了一些问题先贴hexo的网站https://hexo.io/themes/然后是问题:$ hexo g//命令INFO Start processingERROR Theme config load failed.ERROR Process failed: _config.ymlYAMLException: bad indentation of a mapping entry at line 73, column 5: hexo-generator-feed报错!对!就是最下面的这个 - hexo-generator-feed 我也看不懂啥意思,找了半天理由,于是我机制的去官网档了一份原来的,一对比,这是多出来的,之前我还在怀疑空格的问题,原来这不是亲生的!删!痛快华丽丽的删了,然后瞬间正常.简直不要太脆弱.赶紧继续今天的学习!记录下mongodb的开启方式,省的又忘记了首先要找到mongodb的路径D:\mongodb\bincmd要跳到指定路径下,后启动mongod –dbpath=E:\Blog2\db –port=27018 如果git提交不上多数是因为敏感词在模板语法两边用 进行注释即可 ESC下面的键 //&amp;#123% extends &#39;layout.html&#39;%} 继承模板页进行渲染,实现模块复用//layout页面复用//// &amp;#123% block maini %}&amp;#123% endblock %}////index页面//&amp;#123% extends &#39;layout.html&#39;%}//&amp;#123% block maini%}//// Hello, &amp;#123&amp;#123userInfo.username}}!// 欢迎进入管理////&amp;#123% endblock%}////maini.js//进行渲染 res.render(‘mainm/index’,&amp;#123// userInfo:req.userInfo //全局路由均可访问//});//index.html可以进行判断语法//&amp;#123%if userInfo.isAdmin%}////&amp;#123%else%}////&amp;#123%endif%}//////tr&gt;th*4 按table键会重新加载样式// User.find().limit(2).then(function()&amp;#123})//limit()限制条数// &amp;#123% extends &#39;layout.html&#39;%}和 &amp;#123%include &#39;page.html&#39;%}有什么区别吗?// layout是最大的包裹层// 子页面通过extend来继承父页面的html,页面变量不会继承// include同级引入一段页面,可以继承数据,需要通过js路由进行调用.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-博客3]]></title>
    <url>%2F2017%2F06%2F07%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A23%2F</url>
    <content type="text"><![CDATA[本章设计到用户前端页面逻辑设计等主要的内容是router路由的学习话不多说action~ 概念链接:http://www.cnblogs.com/zapple/p/5683016.html一:模块依赖,例如var express = require(‘express’), http = require(‘http’), path = require(‘path’), mongoose = require(‘mongoose’), hash = require(‘./pass’).hash;var app = express() 二:配置和中间件中间件:Express里有个中间件（middleware）的概念。所谓中间件，就是在收到请求后和发送响应之前这个阶段执行的一些函数。中间件其实就是一个访问express应用串入的req，res，nex参数的函数，这个函数可以访问任何通过req，res传入的资源。要在一条路由的处理链上插入中间件，可以使用express对象的use方法。该方法原型如下： app.use([path,] function [, function…])当app.use没有提供path参数时，路径默认为“/”。当你为某个路径安装了中间件，则当以该路径为基础的路径被访问时，都会应用该中间件。比如你为“/abcd”设置了中间件，那么“/abcd/xxx”被访问时也会应用该中间件。中间件函数的原型如下： function (req, res, next)第一个参数是Request对象req。第二个参数是Response对象res。第三个则是用来驱动中间件调用链的函数next，如果你想让后面的中间件继续处理请求，就需要调用next方法。给某个路径应用中间件函数的典型调用是这样的：app.use(‘/abcd’, function (req, res, next) { console.log(req.baseUrl); next();}) Express提供了一个static中间件，可以用来处理网站里的静态文件的GET请求，可以通过express.static访问。express.static的用法如下：express.static(root, [options])第一个参数root，是要处理的静态资源的根目录，可以是绝对路径，也可以是相对路径。第二个可选参数用来指定一些选项，比如maxAge、lastModified等var options = { dotfiles: ‘ignore’, etag: false, extensions: [‘htm’, ‘html’], index: false, maxAge: ‘1d’, redirect: false, setHeaders: function (res, path, stat) { res.set(‘x-timestamp’, Date.now()); }}app.use(express.static(‘public’, options));上面这段代码将当前路径下的public目录作为静态文件，并且为Cache-Control头部的max-age选项为1天。还有其它一些属性，请对照express.static的文档来理解。使用express创建的HelloExpress项目的app.js文件里有这样一行代码：app.use(express.static(path.join(_dirname, ‘public’)));这行代码将HelloExpress目录下的public目录作为静态文件交给static中间件来处理，对应的HTTP URI为“/”。path是一个Node.js模块，_dirname是Node.js的全局变量，指向当前运行的js脚本所在的目录。path.join()则用来拼接目录。 routerExpress还提供了一个叫做Router的对象，行为很像中间件，你可以把Router直接传递给app.use，像使用中间件那样使用Router。另外你还可以使用router来处理针对GET、POST等的路由，也可以用它来添加中间件，总之你可以将Router看作一个微缩版的app。 var express = require(‘express’);var router = express.Router(); / GET home page. /router.get(‘/‘, function(req, res, next) { res.render(‘index’, { title: ‘Express’ });});module.exports = router;index.js创建了一个Router实例，然后调用router.get为“/”路径应用了路由函数。最后呢使用module.exports将Router对象导出。下面是app.js里引用到index.js的代码：var routes = require(‘./routes/index’);…app.use(‘/‘, routes);第一处，require(‘./routes/index’)将其作为模块使用，这行代码导入了index.js，并且将index.js导出的router对象保存在变量routes里以供后续使用。注意，上面代码里的routes就是index.js里的router。第二处代码，把routes作为一个中间件，挂载到了“/”路径上。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活-电影喜剧之王]]></title>
    <url>%2F2017%2F06%2F06%2F%E7%94%9F%E6%B4%BB-%E7%94%B5%E5%BD%B1%E5%96%9C%E5%89%A7%E4%B9%8B%E7%8E%8B%2F</url>
    <content type="text"><![CDATA[只有看懂了《喜剧之王》这些细节，才会知道周星驰有多伟大!《喜剧之王》这部戏，除了刻画了柳飘飘跟尹天仇的爱情之外，还有尹天仇对于他梦想的追求这一条主线。对于这部自传体电影，星爷在表现一个未成名的小人物在奋斗时的彷徨和坚持可是下了大功夫的，每一处细节都值得我们反复观看。尹天仇因为在片场表演欲望太过于强烈闯了大祸，而被导演和李娟儿（莫文蔚）大骂一场赶出了片场。在回家途中，想拿一个盒饭当午餐而被场务（吴孟达）制止并辱骂。场务把饭扔给了狗狗：“屎你是一滩屎，命比蚁便宜……”面对这样的羞辱，几秒钟之内，尹天仇从强颜欢笑到笑不出来的尴尬，他只能默默忍受。（这里不得不赞一下星爷的演技，把小人物的懦弱演得无比贴切）孤独的夜晚，狭小的房间，失意落魄的尹天仇。不知前路如何。墙上那一堆海报，给这黑暗的房间带来了一丝暖色。发呆时面对着这些海报，吃饭时也面对着这些海报，因为这些都是他的梦想。或许大家在看这部电影的时候，会有一种尹天仇和周星驰形象重叠的错觉，即尹天仇最终是一定会走向成功，会成为一个像星爷那般出色演员的错觉。假如尹天仇的成功是确定的，那么他现在所付出的种种努力无疑都是值得的。一个人若可以确定自己的努力一定会获得回报，那么对于自己的梦想的坚持会显得更为容易一些。但电影中的情况不一定是这样，尹天仇并不是星爷，他只是跑龙套的小人物，是个连想要个盒饭填饱肚子都会遭到场务羞辱的人，这个人物并不确定自己未来能否在演艺事业中取得成就，他或许一辈子都是个死跑龙套，一辈子都住在这昏黄的小屋，一辈子都在福利社兼职个小管理员，谁都无法确定（包括他自己）他现在所付出的努力一定会给他带来成功。所以，作为一个普通人，尹天仇眼神中有些愁闷和疑虑是正常的，他也有怀疑自己到底是不是演员这块料的时候。但是，面对一切都是未知， “漆黑一片” 的未来，他心中怀有希望 “天亮后便会好美的”，并且乐观面对生活。我们有时候会患得患失，怀疑自己现在坚持做的事到底有没有意义；有时候觉得长路漫漫目标那么遥远，觉得很疲倦很想放弃；有时候早上起来看着镜中的自己，也不知道自己的未来何去何从。我窃以为《喜剧之王》应该会是星爷最喜欢的电影，星爷在这部电影里彻彻底底的做了回自己。他可能想告诉观众很多，告诉他们演戏是多么的有趣多么的复杂，自己跑过龙套又演过主角，像过屎又轰轰烈烈过。但是到最后，星爷好像又不想讲这些了。对着那些看着电影或哭或笑的观众们，星爷整理了整理发型，给自己一个特写。 其实，他是一个演员。在这个日渐浮躁的社会里，轻易的谈论”梦想“二字逐渐变得尴尬，不是大家不再有梦想，而是大多数人不再相信梦想，以至于大多数人羞于谈梦想。但是，当你生于此世，不总归要有点梦想才有意思吗？《喜剧之王》就是告诉观者，拥有梦想和追逐梦想的意义，是那么重要。有没有那么一部分人会联想到自己？你也有梦想，也在为之追逐，你不远万里，背井离乡，在大城市孑然一身地奋斗，你租不起一千多的房子，稍好一点住隔断，次一点住地下室，你每天挤公交地铁，在一个公司当一个小职员只为填饱肚子，每天下班在路边吃麻辣烫，每个周末宅家里闭门不出，你穿着廉价衣服，吃着便宜饭菜，住着逼仄房子，你在很多人的眼里被冠以“屌丝”标签……但你有梦想，并且你也知道自己有梦想，并且愿意在生活如此艰难的情况下坚持追逐自己的梦想——你也是尹天仇。城市那么大，能者那么多，机会那么少，梦想都不小，生活艰不拆，是什么让你觉得自己活得至少还有点意义？《喜剧之王》告诉我们，不要做咸鱼，要做有梦想的人，即便是影片结尾，尹天仇依旧没能实现梦想，也还是显得伟大——梦想的意义，就在于你是否相信并为之努力，所有奋斗过的梦想，即使没有实现，也值得尊敬。《喜剧之王》在电影技术上，没有格外突出；在电影艺术上，也谈不上拔萃；但就是这样一部电影，在你看完之后，内心会为之深深触动——一个小人物的梦想，在浩瀚的生活面前，原来可以这么伟大。很多人喜欢这部电影，大抵也都是有所触动，或者产生了某些共鸣，这也正是《喜剧之王》值得人喜欢的地方。它几乎比很多号称爱情电影的电影更像爱情电影，因为它不仅讲述了一个爱情故事，还让这样一份爱情触动了很多人，以至于多年以后，人们提起这部电影的时候，会脱口而出那句经典的“我养你啊”。而本片最有泪点的一幕，或者说电影最伟大的一幕，则是这样一幅画面： 青春已不再,奋斗犹正时,此若不努力,枉为少年志.]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-博客2]]></title>
    <url>%2F2017%2F06%2F06%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A22%2F</url>
    <content type="text"><![CDATA[前期的初始化及基本路由的配置已经完成,主要是内容是模板的初始化设定.下面进行分模块开发和数据库等操作. 模块划分:根据功能进行模块划分:前台模块,后台管理模块,API模块(ajxa调用的一些接口)使用app.use()进行划分app.use(‘/admin’,require(‘./router/admin’));处理后台管理的urlapp.use(‘/api’,require(‘./router/api’));处理apiapp.use(‘/‘,require(‘./router/main’));处理前台展示 各js如main.js:var express=require(‘express’);var router=express.Router();//路由模块 ,监听app.js里以/admin开头的url. router.get(‘/‘,function(req,res,next){ res.send(‘首页’);}); module.exports =router; //将路由对象返回出去 安装数据库:npm(node包管理工具)的使用,第三方node模块的管理工具.开启mongodb数据库https://www/mongodb.com(貌似需要翻墙,请使用蓝灯)安装教程需要百度,其中安装里有一个选择custom方便以后查找安装位置.配置操作:mongod –dbpath=数据文件保存路径 –port=27018(端口)可视化工具安装http://blog.csdn.net/wrian_ban/article/details/51085678操作命令http://mongoosejs.com/第一次链接时候发现network is unreachable时请将localhost换成本机ip.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-博客1]]></title>
    <url>%2F2017%2F06%2F05%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-%E5%8D%9A%E5%AE%A21%2F</url>
    <content type="text"><![CDATA[到了毕业季了,老师们也是有仇报仇有怨报怨,看着哪个不顺心的,使劲卡那个老师的学生毕业.大学教授虽然很多都是桃李芬芳,但总有那么几个没品没德的亲眼到学校参加了一场毕业答辩,背后真是暗流涌动啊. 网站架构就略去了 技术框架:Nodejs Express Mongodb 第三方模块&amp;中间件 bodyParser:解析post请求数据cookies:读写cookiesswig:模板解析引擎mongoose:操作mongodb数据markdown:markdown语法解析生成模块 操作:1:初始化 npm init2:安装框架npm install –save expresspackage.json的配置如下: { “name”: “blog2”, “version”: “1.0.0”, “description”: “”, “main”: “index.js”, “scripts”: { “test”: “echo \”Error: no test specified\” &amp;&amp; exit 1” }, “author”: “”, “license”: “ISC”, “dependencies”: { “body-parser”: “^1.17.2”, “cookies”: “^0.7.0”, “express”: “^4.15.3”, “markdown”: “^0.5.0”, “mongoose”: “^4.10.4”, “swig”: “^1.4.2” }}3:目录结构db:数据库存储目录models:数据库模型文件目录node_modules:node第三方模块目录public:公共文件目录(css,js,image…)routers:路由文件目录schemas:数据库结构文件目录views:模板视图文件目录app.js:应用启动入口文件 4:编写app.js内容 处理请求输出:路由绑定:通过app.get()/app.post()等方法可以把一个url路径和一个或n个函数进行绑定app.get(‘/‘,function(req,res,next){})req:request对象-保存客户端请求相关的一些数据-http.requestres:response对象-服务端输出对象,提供了一些服务器端输出相关的一些方法next:方法,用于执行下一个和路径匹配的函数内容输出:通过res.send(string)发送内容至客户端 使用模板:后端逻辑和页面表现分离 var swig=require(‘swig’);app.engine(‘html’,swig.renderFile);定义模板引擎,使用swig,renderFile方法解析后置为html的文件app.set(‘views’,’./views’);设置模板存放目录app.set(‘view engine’,’html’)注册模板引擎swig.setDefaults({cache:false});取消缓存机制,不需要重启应用.原因: 当新建页面后必须重启应用,否则只会读取模板上次解析后存放在内存中的页面.这种缓存机制是为了提高页面的加载效率. app.use(‘/public’,express.static(__dirname+’/public’)) //设置静态文件托管//如果用户调用的文件是/public开头,则调用后面的方法去处理. 逻辑:用户发送http请求-&gt;url-&gt;解析路由-&gt;找到匹配的规则-&gt;执行绑定的函数-&gt;返回对应的内容至用户. /public -&gt;静态文件 -&gt;直接读取指定目录下的文件-&gt;返回给用户 动态-&gt;处理业务逻辑,加载模板,解析模板-&gt;返回数据给用户代码如下:var express= require(‘express’); //加载模块var swig=require(‘swig’);//加载模板处理模块var mongoose=require(‘mongoose’);//加载数据库模块var app=express();//创建app应用 等同于node.js http.createServer(); app.use(‘/public’,express.static( __dirname+’/public’)) //设置静态文件托管//如果用户调用的url文件是/public开头,则调用后面的方法去处理.返回其文件 app.engine(‘html’,swig.renderFile);//定义当前应用所使用的模板引擎//第一个参数:模板引擎的名称,同事也是模板文件的后缀//第二个参数,用于解析处理模板内容的方法 app.set(‘views’,’./views’);//第一个参数必须是views .第二个参数是目录 app.set(‘view engine’,’html’);//第一个参数必须是 view engine,第二个参数和app,engine方法中定义的模板引擎名称(第一个参数)必须相同! swig.setDefaults({cache:false}); app.get(‘/‘,function(req,res,next){ // res.send(‘欢迎光临我的博客’) //读取views目录下的指定文件,并解析返回给客户端 res.render(‘index’); //第一个参数:表示模板的文件,相当于views目录下的文件index.html.(可以自定义新建这个页面) //第二个参数:传递给模板使用的数据.})mongoose.connect();app.listen(8081);//监听http请求]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站页面优化]]></title>
    <url>%2F2017%2F06%2F01%2F%E7%BD%91%E7%AB%99%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[经常在群里活跃,有不少面试的同仁在回答面试或者笔试的时候会问到这个.本着求根问底的精神,在网上找了一些资料,现整理如下以后还会继续补充一.页面优化1.HTTP优化 只要是请求就必然有成本,时间成本资源成本等,一个完整的请求需要经过DNS寻址,与服务器建立连接,发送数据,等待服务器响应,接受数据这样一个漫长负责的过程.而请求所带的数据需要占用带宽,而浏览器进行并发请求的请求书是有上限的,所以这样必然会导致浏览器需要分批处理,从而用户等待时间变长.(1).减少请求数,例如百度首页. (2).合理设置HTTP缓存,原则就是缓存越多越久越好. (3).css和js都可以压缩合并,甚至包括图片,压缩工具请百度~ (4).css sprites 合并图片,将图片集中在一个大图上. (5).Inline Image,使用data: URL scheme的方式将图片嵌入到页面或CSS中,虽然说的很高大上,其实就是用Base64位码. 2.脚本优化(1).将外部脚本置底.浏览器是可以并发请求的,但是js脚本却是单线程的,所以外链脚本在加载时会阻塞其他资源,所以可以按照需求将脚本适当的置于靠后的部分.外链脚本:静态资源库http://cdn.code.baidu.com/ (2).异步执行inline脚本(网页上部引用的本地脚本).inline脚本在执行的时候一样阻塞并发请求,而浏览器页面处理方面是单线程的,从上到下依次渲染.建议是进行异步处理,Html5引用web worker机制解决问题.a.普及 web worker(工作线程):允许开发人员编写狗狗长时间运行而不被用户所 中断的后台在程序,去执行事务或者逻辑并同时保证页面对用户的响应.简而言之就是允许JS创建多个线程,但是子线程完全受主线控制,且不得操作DOM. (3).lazy load js.一种是为那些流量特别大的页面专门定制一个专用的mini版框架，另一种则是Lazy Load。YUI则使用了第二种方式，在YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载 (4).将CSS放在HEAD中. (5).异步请求Callback. 二 seo引擎优化增强搜索引擎营销的效果使网站的产品相关的关键词能有好的排位。使网站更容易被搜索引擎收录，提高用户体验和转化率进而创造价值.(1).网站重构.就是将所有的字体、样式等表现形式都写成DIV+CSS的方式，CSS放在单独文件里，Javascript也放在单独文件，HTML里面只有文字内容。凡是可以使用外部文件调用的，就使用外部文件调用，可以不出现的，尽量不出现，在正文中，全部以文字为主，不要出现CSS代码。这样做的好处是，HTML文件的代码被精简，文件变小，搜索引擎在索引网站页面时，可以更好地索引和识别网站的内容信息，并能准确抓取页面正文的内容。 (2).Meta标签优化.对于Meta标签，主要有title、description、keywords三个地方，其余的meta标签不加也没事。就重要性而言，title在页面优化中绝对占据很重要的位置。title标题标签告诉用户和搜索引擎一个特定网页的主题是什么。标签通常放在HTML文档的标签内。理想情况下，应该为网站的每一个网页创建唯一的title页面标题。关于title的写作，title标签应该准确描述网页的内容，使用简短的，但具描述性的标题标签——短的标题同样可以包含丰富的信息。如果标题太长，搜索引擎只会在搜索结果里显示其部分内容。尽量不要堆积太多关键词，如果是长标题，可以包含关键词1-2次，而且关键词不用靠的太近。description描述标签提供了关于这个网页的总括性描述，网页的标题可能是由一些单词和短语组成的，而网页的描述元标签则常常是由一两个语句或段落组成的。如果网页摘要里的某个词语恰好出现在用户的查询里，那么这个词语将被高亮显 示，如果描述标签写的好，可以提升页面的点击率。关于description的写作，description标签准确概括该网页的内容，每一个网页应该创建各不相同的描述标签，避免所有的网页或很多网页使用千篇一律的description标签。keywords关键词标签，对于页面优化来说，重要性已经大不如前，甚至有种说法是，keywords标签已经没用了，不过，就算搜索引擎已经不将keywords考虑进，写一下keywords标签可能还会有些作用，不过keywords里面不要堆砌太多关键字，否则可能适得其反，写上4、5个核心关键字即可。 (3).Heading标签优化. Heading标签（H标签）通常用来为用户呈现网页的结构。HTML语言里一共有六种大小的H标签，从最重要的H1到H6，权重依次降低。最常用的包括H1、H2标签，H1代表着大标题，H2是小标题。按照这个意思，最重要的关键词设置在H1标签中，和关键词相关的词组再放到H2标签中，依次往后推。 (4).Alt优化. 图片的优化对于网站页面来说也非常重要，所有的图片都拥有一个Alt属性，对于图片的优化主要是针对这个属性的优化，优化图片的alt属性可以使得图片搜索引擎能更好地理解图片。 (5).链接锚文本优化.锚文本是链接上可以被点击的文字，它通常被放在锚标记A标签中间，锚文本主要作用是描述链接页面的一些情况，锚文本写得越好，用户浏览网站就越容易，搜索引擎也能更容易地理解链接到的页面内容。 (6).关键词优化.关键词的布局，最重要的几个位置是开头，特别是第一段开头的50-150个字，需要包含一次关键词，然后中间正文中，出现2-3次关键词或者近义词，文章的结尾，也包含一次关键词就可以了。关键字密度有时候会影响到关键词的排名，不建议采取一些极端的方法来提高关键字密度。合理的目标关键字密度可以通过关注一些长尾关键字来进行优化。长尾关键词(Long Tail Keyword)是指网站上非目标关键词但也可以带来搜索流量的关键词。长尾关键词的特征是比较长，往往是2-3个词组成，甚至是短语。通过长尾关键词挖掘工具可以找到不少长尾关键词，将这些词组织到文章里，就可以做到既不提高关键词密度，又能提升关键词在页面的权重。 (7).内容优化. 1、撰写容易阅读，浅显易读的内容，有条理地组织内容，段落清晰，让读者能够清楚地了解内容的起始和逻辑，避免将大量不同主题的内容放在同一页上，却没有任何的分段、标识和层次划分。2、提供原创的、独特新颖的内容，不要模仿甚至抄袭别人的内容。原创内容不仅仅能吸引更多的用户，还可以招揽更多的回头客。而搜索引擎对于原创内容的识别能力也越来越高。三.代码优化未完待续http://blog.csdn.net/li2274221/article/details/25193381没有细看,但是很多内容很不错.]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>网页优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-6]]></title>
    <url>%2F2017%2F06%2F01%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-6%2F</url>
    <content type="text"><![CDATA[程序员不易,坐久了腰好疼啊~继续开始使用node.js进行web开发 http://www.baidu.com请求后动作1.浏览器发送http请求,请求指定的baidu.com的主机(DNS解析IP地址)2.该ip地址的设备接受到请求后会对该请求进行分析和处理.3.服务器处理完成后,返回对应的数据到用户浏览器.4.浏览器接受把服务器返回的数据,然后进行分析处理.渲染等操作. var http=require(‘http’);//通过http模块下的createserver创建并返回一个web服务器对象.var server=http.createServer(); //监听端口.端口:网络数据交互如QQ等数据的传输和发送都需要通过网卡,划分好对应的’分机’才能对应监听//一个应用程序可以监听多个端口数据,一个端口数据只能被一个应用监听.//server.listen(port,[hostname],[backlog],[callback])//port:监听端口.// hostname:主机名(Ip/域名).// backlog:连接等待队列的最大长度.(允许多少客户端等待)// callback:调用listen方法并成功开启监听后,//会触发一个listning事件,callback将作为该事件的执行函数.//端口号1-1024 给系统使用,server.on(‘error’,function(err){ //服务开启失败时触发 console.log(err);}) server.on(‘listening’,function(){ //调用listen方法时触发 console.log(‘listen’); })server.on(‘request’,function(req,res){ //有客户端发送请求到该主机和端口的请求的时候触发 console.log(‘有请求了’); //req:存储跟客户端发送请求的相关信息 // console.log(req); //res:服务端数据处理,向客户端发送指定的数据 res.write(‘hello’); //(chuank,encoding):发送一个数据块到响应正文中,后面是编码方式. res.end(); //(chuank,encoding):当所有的正文和头信息发送完成以后会调用该方法告诉 // 服务器数据已经全部发送完成,这个方法在每次完成信息发送以后必须调用,并且是最后调用.})res.writeHead(200,’dddd’,{ //浏览器接受到的永远都是字符串,会根据header里的类型进行设置. ‘content-type’:’text/html’, }) ;server.listen(8089,’localhost’); //浏览器输入 http://localhost:8089/ request方法就会有响应. //////////////////////////////////////// var http=require(‘http’); var url=require(‘url’);var server=http.createServer();(var fs=require(‘fs’);)server.on(‘request’,function(req,res){ var urlStr=url.parse(req.url); (var htmlDir=_dirname+’/html’;) console.log(urlStr);//将url解析成一个json对象进行查看. switch (urlStr.pathname){ case ‘/‘: ( sendData(htmlDir+’index.html’,req,res)) res.writeHead(200,{ //可以使用fs模块实现分离 ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘shouye’); break; case ‘/user’: res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘geren’); break; default: res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘beichidiao’); break; } console.log(req.url);//访问路径; ?后面的部分query string 查询字符串}) ;function sendData(file,req,res){fs.readFile(file,function(err,data){if(err){ res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘shouye’);}else{ res.writeHead(200,{ ‘content-type’:’text/html;charset=utf-8’ }) ; res.end(‘data’);}})}server.listen(8080,’localhost’); log:Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: ‘?=1’, query: ‘=1’, pathname: ‘/a’, path: ‘/a?=1’, href: ‘/a?=1’ }/a?=1 //////////////////////////////////////// urlStr里有query的值即是提交的表单Query.String: 序列化一个对象到一个query string 可以选择是否覆盖默认的分分割符(‘&amp;’)和分配符(‘=’).也可以自定义 eg:username=ab&amp;password=123 Query.parse:反序列化]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-5]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-5%2F</url>
    <content type="text"><![CDATA[本章开始学习前端项目自动化包括项目构建,自动合并等话不多说 继续开始fs模块介绍http://www.jianshu.com/p/5683c8a93511PS:{}和[]有啥区别?答案是{}里面是对象,[]则是数组 ///////////////////////////// 初始化文件项目 var projectData={ ‘name’:’miaov’, ‘fileData’:[ { ‘name’:’css’, ‘type’:’dir’ }, { ‘name’:’js’, ‘type’:’dir’ }, { ‘name’:’images’, ‘type’:’dir’ }, { ‘name’:’index.html’, ‘type’:’file’, ‘content’:’\n\t\n\t\ttitle\n\t\n\t\n\t\thello\n\t\n‘, } ] }; if(projectData.name){ fs.mkdirSync(projectData.name); var fileData=projectData.fileData; if(fileData &amp;&amp; fileData.forEach){ fileData.forEach(function(f){ f.path= projectData.name+’/‘+ f.name; f.content= f.content || ‘’; switch (f.type) { case ‘dir’: fs.mkdirSync(f.path); break; case ‘file’: fs.writeFileSync(f.path, f.content); break; } }) } } /////////////////////////////]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-4]]></title>
    <url>%2F2017%2F05%2F31%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-4%2F</url>
    <content type="text"><![CDATA[生活不易,且行且珍惜.忙活了三天,电脑没碰,生活上的事情焦头烂额,继续吧.上次的学习主要是fs文件模块的使用,包括fs.write,fs.open,fs.read等.日常错误就是对其读写操作属性的配置.下面继续开始下一章. fs.readFile(filename,[options],callback)//异步读取一个文件的全部内容 fs.readFileSync(filename,[options])//同步 fs.unlink(filename,callback)//异步删除一个文件 fs.unlinkSync(path)//同步 fs.rename(‘oldname’,’newname’,callback)//重命名 fs.stat(path.callback)//读取文件信息(属性) { ‘0’: null, ‘1’: Stats { dev: 826654, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 60517119993054080, size: 17, blocks: undefined, atime: 2017-05-27T08:29:26.420Z, mtime: 2017-05-27T08:45:50.850Z, ctime: 2017-05-27T08:45:50.850Z, birthtime: 2017-05-27T07:51:00.935Z } } fs.watch(filename,[options],[listener])//不稳定,观察指定路径的改版 回调函数里的参数(event,filename)监听内容及命名的变化 (change,rename)event 为rename表示指定的文件或目录中有重命名、删除或移动操作或change表示有修改，filename表示发生变化的文件路径///////////////////////////// 下面是操作文件夹的一些内容fs.mkdir(path,[mode],callback) //创建文件夹fs.mkdir(‘./1’,function(){ console.log(arguments);//0:null})fs.mkdirSync(path,[mode])//同步版本 fs.readdir(path,callback)//读取文件夹fs.readdir(‘../learnnode’,function(err,fileList){ fileList.forEach(function(f){ fs.stat(f,function(err,info){ switch (info.mode){ case 16822: console.log(‘文件夹’+f); break; case 33206: console.log(‘文件’+f); break; default: console.log(f); break; } }) })}) readdir(‘../learnnode’,function(err,fileList){ fileList.forEach(function(f){ fs.stat(f,function(){ console.log(arguments); }) })})输出:{ ‘0’: null, ‘1’: Stats { dev: 826654, mode: 16822, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 3940649674220553, size: 0, blocks: undefined, atime: 2017-05-31T02:35:17.146Z, mtime: 2017-05-31T02:35:17.146Z, ctime: 2017-05-31T02:35:17.146Z, birthtime: 2017-05-31T02:35:17.146Z } }{ ‘0’: null, ‘1’: Stats { dev: 826654, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 14355223812513196, size: 6, blocks: undefined, atime: 2017-05-27T07:16:26.216Z, mtime: 2017-05-27T07:16:30.209Z, ctime: 2017-05-27T07:16:30.209Z, birthtime: 2017-05-27T06:24:41.427Z } } 注意!mode 33206代表文件,16822代表文件夹fs.readdirSync(path)//同步版本 fs.rmdir(path,callback)//删除文件夹 fs.rmdir(path)//同步版本 /////////////////////////////]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-3]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-3%2F</url>
    <content type="text"><![CDATA[花了一上午，在领导的指示下做了一个手机端的界面http://zhaopin.yanhuatong.com/挺丑，也就只能这样了，哈哈下午打卡，话不多说，开始吧上次学了点Buffer的指示,其实主要还是字符的拼接切割,但是又涉及到IO的操作.重点:Buffer会占用内存,写入后不会轻易更改.类方法,静态方法什么是静态方法?我也没理解透,查阅了一些资料↓静态方法也叫类方法:类方法属于类，使用时不需要实例化一个对象，直接使用类名称就可以使用。(在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到JVM关闭。)成员方法也叫对象方法:对象方法属于某个对象实例，必须先有一个对象，才可以使用(实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被JVM 回收之后，也跟着消失。) ///////////////////////////// console.log(Buffer.isEncoding(‘utf-8’))//true console.log(Buffer.byteLength(‘utf-8’))//5 console.log(Buffer.byteLength(‘妙味’)) //6var str=’miaov’;var str2=’妙味’;var list=[new Buffer(str),new Buffer(str2)];console.log(list);//[ , ] var bf=Buffer.concat(list);console.log(bf);//var str3= bf.toString();console.log(str3);//miaov妙味//如果在输出的时候使用字符串拼接(‘xxxx’+str)会自动转化为字符串而不需要toString ///////////////////////////// File System -文件系统模块 使用方法 :require(‘fs’) fs.open(path,flags,[mode],callback);(异步,不耽误后续动作执行)path:要打开文件的路径;flags:打开文件的方式,常用的:读/写;mode:设置文件的模式:读/写/执行 4/2/1;callback:回调 err:文件打开失败的错误保存在err里面,如果成功err为Null. fd:被打开文件的标识. fs.opnSync(path,flags,[mode]);(同步,无回调函数) ///////////////////////////// fs.read(fd,buffer,offset,length,position,callback);//从指定文档标识符fd读取文件数据.fd:通过open方法成功打开一个文件返回的编号.buffer:buffer对象offset:偏移量,新的内容添加到buffer中的起始位置length:添加到buffer中内容的长度position:读取的文件中的起始位置callback:回调函数:参数有err newbuflength(长度) newbf(更改后的buffer) var bf1=new Buffer(10); console.log(bf1); fs.read(fd,bf1,0,4,null,function(err){ console.log(bf1);//// ///////////////////////////// fs.write(fd,buffer,offset,length,position,callback);fd:打开的文件buffer:要写入的数据offset:buffer对象中要 写入的数据的起始位置length:要写入的Buffer数据的长度postition:fd中起始位置callback:回调offset和position的区别是什么?offset是指new Buffer(‘123’);里的偏移量position是指fd文件被修改的起始位置 var fs=require(‘fs’); fs.open(‘1.text’,’r’,function (err,fd){ if(err){ console.log(err); } else { /*var bf1=new Buffer(10); console.log(bf1); fs.read(fd,bf1,0,4,null,function(err){ console.log(bf1); }) */ var bf=new Buffer(&apos;123&apos;); fs.write(fd,bf,0,3,0,function(){ console.log(arguments); }) } })//会报错,那是为什么呢?报错如下{ ‘0’: { Error: EPERM: operation not permitted, write at Error (native) errno: -4048, code: ‘EPERM’, syscall: ‘write’ }, ‘1’: 0, ‘2’: }注意:我们回头看起,Buffer有读写操作,当我们以只读的时候打开就无法进行写的操作 所以上面的应该改为:fs.open(‘1.text’,’r+’,function (err,fd){ fs.write(fd,’1234数据’,[encoding编码方式],callback);直接添加字符串 fs.close(fd,callback);关闭打开文件 ,无法进行后续操作. ///////////////////////////// fs.writeFile(filename,data,[options],callback)异步的将数据写入一个文件,如果文件不存在则新建,如果文件原来存在,则会被替换.data:可以是一个string,也可以是一个原生buffer.var fs=require(‘fs’);var filename=’2.txt’; fs.writeFile(filename,’hello’,function(){ console.log(arguments); }); fs.appendFile(filename,data,[options],callback)异步的将数据添加到一个文件的尾部,如果文件不存在,会创建一个新的文件,data同上.fs.appendFile(filename,’leo’,function(){})fs.appendSync(filename,data,options) 同步模式无返回值!!!fs.exists(filename,function(err){})//检测文件是否存在,true/false同步模式:var fs=require(‘fs’);var filename=’2.txt’; if(!fs.existsSync(filename)){ fs.writeFileSync(filename,’miaov’); console.log(‘xinzengchenggong’) }else{ fs.appendFileSync(filename,’-leo’); console.log(‘zhuijiachenggong’) } 为什么在检测的时候要用同步? 因为同步模式直接返回true,或者false,如果要用异步模式则需要调用callback.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-2]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-2%2F</url>
    <content type="text"><![CDATA[小张来打卡了,这是第二天了,忙活了一上午的数据库,总算成功的导入了.现在可以沉下心来接着看了昨天学习了一些基础的知识,主要还是require和exports的机制.今天努努力开始继续学习吧.ready go! 有点尴尬么 哈哈~http://oqfuveidu.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720170526132504.jpg ///////////////////////////////console.log(_filename);返回当前模块文件的解析后的绝对路径,该属性其实并非全局的,而是模块作用域下的.//console.log(_dirname);返回当前模块文化部所以在目录解析后的绝对路径,该属性也不是全局的,而是模块作用域下的.效果如下:d:\learnnode\6.jsd:\learnnode ///////////////////////////// global:process对象process对象是一个全局对象,可以在任何地方都能访问到,通过这个对象提供的属性和方法, 使我们可以对当前运行的程序的进程进行访问和控制.process.argv:一个包含命令行参数的数组,第一个元素是node,第二个元素是.js文件名称.接下来的元素一次是命令行传入的参数. console.log(process.pid);可以进入资源管理器查看PID:任务进程编号 process.stdin,stdout :标准输入输出流(IO),提供操作输入数据和输出数据的方法 process.stdin.resume();//默认情况下,输入流是关闭的,要监听处理输入流数据,首先要开启输入流.process.stdin.on(‘data’,function(chunk) { console.log(‘yonghushuru’+chunk);});//用于监听用户输入数据 ///////////////////////////// Buffer类:一个用于 更好操作二进制数据的类(全局类) var bf=new Buffer(5);//size[num]创建一个Buffer对象,并未这个对象分配一个大小,当分配空间大小后,其长度固定,无法更改.console.log(bf);//var bf=new Buffer([1,2,3]);console.log(bf);//var bf=new Buffer(‘miaowei’,’utf-8’);//把字符串转成二进制数据,默认utf8console.log(bf);// for(var i=0;i&lt;bf.length;i++){ //bf.length指字节长度,而不是字符串长度.而在utf8编码中一个汉字占3个字节,一个字母或者数字占一个字节. console.log(String.fromCharCode(bf[i]));}//反向输出字符 buf.write():从指定的字符串当中以指定的编码写入指定长度字符.var str=”miaovvvvvv”;var bf=new Buffer(5);bf.write(str) ;console.log(bf);//bf.write(str,1,3) ; 1:偏移量(从对象的第几位开始写入,从0开始),3:指长度.console.log(bf);// var bf=new Buffer(‘miaov’);console.log(bf.toString(‘utf-8’,1,3));//ia var bf2=new Buffer(‘妙味’);console.log(bf2.toString(‘utf-8’,1));//��味 console.log(bf2.toJSON());//{ type: ‘Buffer’, data: [ 229, 166, 153, 229, 145, 179 ] }调用字符串序列号这个实例 slice(2,4);引用相同的内存地址,然后进行切割成新的字节数组buffer.bf.copy(bf4);输出bf4的Buffer值 今天完结,明天继续.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于node.js的学习-1]]></title>
    <url>%2F2017%2F05%2F25%2F%E5%85%B3%E4%BA%8Enode-js%E7%9A%84%E5%AD%A6%E4%B9%A0-1%2F</url>
    <content type="text"><![CDATA[作为一个刚刚入行的小白,在学习vue.js的这种进阶的知识后发现自己还欠了很多的基础内容.在思考了很久之后我决定补一下这些知识,一步一个坎,总要踩过去.那么又面临一个问题.node.js和html5 一个偏后端一个偏前端该选择哪个呢?我很纠结在思考了一个上午后我觉得我还是需要先学node.js.为什么要学它.我的理由很简单:node.js是一门可以处理后端的技术,这样我就不用学习.net c#一类的了.哈哈…原文地址:https://www.zhihu.com/question/33578075如果有人不懂为什么要学习node.js可以看下上面的链接.视频的学习链接请百度网易云课堂不是打广告计划一个月的时间学习它.那么开始吧~Js组成: 操作浏览器 Ecmascript+BOM+DOM node.js: 操作系统网络等 Ecmascript os file net database相同点:在ECMAScript部分node和js其实是一样的,比如数据类型的定义,语法结构,内置对象等等差异性:顶层对象 js:window node:没有window概念,有global全局对象node:var a=100;console.log(global.a)//undefined//模块化:一个文件就是一个模块,每一个模块都有自己的作用域.//我们使用var来声明一个定义,他并不是全局的,而是属于当前模块下. global.a=200;console.log(a);//100console.log(global.a);//200 在一个模块下定义的变量,其作用域只是当前模块,外部无法调用. 如果想一个模块能够访问另外一个模块中定义的变量,可以: 1.把变量作为global对象的一个属性(不推荐). 2.使用模块对象module:保存提供和当前模块有关的一些信息. console.log(module); Module { id: ‘.’, exports: {}, parent: null, filename: ‘d:\learnnode\4.js’, loaded: false, children: –&gt;加载的模块 [ Module { id: ‘d:\learnnode\5.js’, exports: {}, parent: [Circular], filename: ‘d:\learnnode\5.js’, loaded: true, children: [], paths: [Object] } ], paths: [ ‘d:\learnnode\node_modules’, ‘d:\node_modules’ ] } //在这个module对象,有一个子对象:exports对象,我们可以通过这个对象把//一个模块中的局部变量对象进行提供访问.module.xeports.a=a;var m5= require(‘./5’);//这个方法的返回值,其实就是被加载模块中的module.exports 在模块作用域,还有一个内置的模块对象:exports,他其实就是module.exports. 注意:module.exports=[1,2,3];//expors和module.exports的指向关系会断开,导致exports的输出错误. 在已有的属性进行添加,而不是重写. //_filename:当前文件被解析过后的绝对路径.属于当前模块下的.//模块加载系统:require(‘模块’); eg: require(‘./2.js’); //模块加载机制: 路径 绝对路径:require(‘b:/x/x/2.js’); 相对路径:require(‘./2.js’);//未加./会加载node的核心模块,或者是node_modules require(&apos;./2&apos;)// 1.首先按照加载的模块的文件名称进行查找 2.如果没有找到,则会在模块文件名称后面加上.js的后缀,进行查找. 3.如果还么有找到,则会在文件名称后面加上.json的后缀,进行查找. 4.如果还没有找到,则会在文件名称后面加上.node的后缀,进行查找. 5.还为找到,抛出错误.]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2017%2F05%2F24%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我在Github上第一次搭建博客.遇到了很多的困难也得到了很多的帮助,如果你也想搭建一个这样的博客,不妨参考下这个帮助:https://fzy-line.github.io/ 如果你遇到了在分类和标签上出现无法加载的情况,请不要着急,在你生成的页面后进入/sourse/tags里加入layout: “tags”. 下面是网站的发布流程:新建博客 $ hexo new “我的第一篇博客”到站点目录下的/source/_posts/目录下可以看到生成了名为：我的第一篇博客.md的文件，这是Markdown格式的文件，可以用sublime text3或者notepad++等编辑器打开，也可以下载一个MarkdownPad来编辑Markdown文件。 编辑博客 Hexo默认新建的文章抬头已有title、date、tags等属性，可能缺乏categories和meta标签，想要指定目录就需要添加categories属性，而meta标签则是为了便于搜索引擎的收录。如下： title: 我的第一篇博客date: 2016-12-02 23:44:20 tags: #文章标签 可以省略tags字段是文章的标签，可以指定标签也可以不指定，如果要指定多个标签需要这样做： tags: [Linux,Http,网络]我们可以添加上categories字段，对博客进行分类管理，然后点击主页左侧菜单的分类就可看到具体的分类。例如： categories: Linux 发布博客 $ hexo clean #清除缓存 网页正常情况下可以忽略此条命令 $ hexo generate #生成静态页面至public目录写好之后可以现在本地预览，确定无误之后再部署到Github上。 $ hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） $ hexo deploy #将.deploy目录部署到GitHub需要说明的是： 我们博客文章的编写都是Markdown文件，但是发布到github上的其实是html文件，将Markdown转换成html这个工作我们只要输入hexo generate命令即可，hexo会帮我们完成转换。 hexo命令简写形式 hexo n “我的博客” == hexo new “我的博客”hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>